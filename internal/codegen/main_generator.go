package codegen

import (
	"fmt"
	"strings"

	// "text/template" // Removed
	// "bytes"         // Removed

	"github.com/podhmo/goat/internal/metadata"
	"github.com/podhmo/goat/internal/utils/stringutils" // Re-adding as it's needed by generateMainContent
)

// formatHelpText formats the help text string for inclusion in the generated Go code.
// It handles escaped newlines (\\n) and placeholder single quotes (') for backticks (`).
// It then chooses the best Go string literal representation.
// formatHelpText formats the help text string for inclusion in the generated Go code.
// It handles escaped newlines (\\n) and placeholder single quotes (') for backticks (â€œ).
// It then chooses the best Go string literal representation.
func formatHelpText(text string) string {
	// Initial transformations
	// 1. Replace literal "\\n" with actual newline character '\n'.
	processedText := strings.ReplaceAll(text, "\\n", "\n")
	// 2. Replace placeholder single quote "'" with actual backtick '`'.
	processedText = strings.ReplaceAll(processedText, "'", "`")

	hasNewlines := strings.Contains(processedText, "\n")
	hasBackticks := strings.Contains(processedText, "`")

	if hasNewlines && hasBackticks {
		var sb strings.Builder
		sb.WriteString("`")
		last := 0
		for i, r := range processedText {
			if r == '`' {
				sb.WriteString(processedText[last:i])
				sb.WriteString("`")
				sb.WriteString(" + \"`\" + ")
				sb.WriteString("`")
				last = i + 1
			}
		}
		sb.WriteString(processedText[last:])
		sb.WriteString("`")
		return sb.String()

	} else if hasNewlines {
		return "`" + processedText + "`"
	} else {
		return fmt.Sprintf("%q", processedText)
	}
}

// GenerateMain creates the Go code string for the new main() function
// based on the extracted command metadata.
// If generateFullFile is true, it returns a complete Go file content including package and imports.
// GetEffectiveEnumValues converts enum values to a slice of strings.
func GetEffectiveEnumValues(opt *metadata.OptionMetadata) []string {
	if opt != nil && opt.EnumValues != nil {
		strValues := make([]string, len(opt.EnumValues))
		for i, v := range opt.EnumValues {
			strValues[i] = fmt.Sprintf("%v", v)
		}
		return strValues
	}
	return nil
}

// GenerateMain creates the Go code string for the new main() function
// based on the extracted command metadata.
// If generateFullFile is true, it returns a complete Go file content including package and imports.
// Otherwise, it returns only the main function body.

// generateMainContent will be filled in later.
// For now, it returns a placeholder or minimal valid Go main function.
func generateMainContent(cmdMeta *metadata.CommandMetadata, helpText string) (string, error) {
	var sb strings.Builder

	sb.WriteString(`// This main function was auto-generated by goat.
func main() {
	ctx := context.Background()
	isFlagExplicitlySet := make(map[string]bool)
`)

	if helpText != "" {
		sb.WriteString(fmt.Sprintf(`
	flag.Usage = func() {
		fmt.Fprint(os.Stderr, %s)
	}
`, formatHelpText(helpText)))
	}

	if cmdMeta.RunFunc.OptionsArgTypeNameStripped != "" {
		// Initial declaration removed

		if cmdMeta.RunFunc.InitializerFunc != "" {
			sb.WriteString(fmt.Sprintf(`
	// 1. Create Options using the initializer function.
	options := %s()
`, cmdMeta.RunFunc.InitializerFunc))
		} else {
			sb.WriteString(fmt.Sprintf(`
	// 1. Create Options with default values (no initializer function provided).
	options := new(%s) // options is now a valid pointer to a zeroed struct

	// The following block populates the fields of the options struct.
	// This logic is only executed if no InitializerFunc is provided.
`, cmdMeta.RunFunc.OptionsArgTypeNameStripped))
			for _, opt := range cmdMeta.Options {
				switch opt.TypeName {
				case "string":
					// If opt.DefaultValue is nil, this assignment is skipped.
					// options.FieldName will retain its zero value ("") from new(OptionsType).
					if opt.DefaultValue != nil {
						valStr := fmt.Sprintf("%v", opt.DefaultValue)
						defaultValueStr := `""` // Default for empty string after conversion
						if valStr != "" {
							defaultValueStr = fmt.Sprintf("%q", valStr)
						}
						sb.WriteString(fmt.Sprintf("	options.%s = %s\n", opt.Name, defaultValueStr))
					}
				case "int":
					if opt.DefaultValue != nil {
						defaultValueStr := "0" // Default to 0
						if dvInt, ok := opt.DefaultValue.(int); ok {
							defaultValueStr = fmt.Sprintf("%d", dvInt)
						} else {
							// Attempt to format non-int default value, though this path is less ideal
							defaultValueStr = fmt.Sprintf("%v", opt.DefaultValue)
						}
						sb.WriteString(fmt.Sprintf("	options.%s = %s\n", opt.Name, defaultValueStr))
					}
				case "bool":
					if opt.DefaultValue != nil {
						defaultValueStr := "false" // Default to false
						if dvBool, ok := opt.DefaultValue.(bool); ok {
							defaultValueStr = fmt.Sprintf("%t", dvBool)
						} else {
							// Attempt to format non-bool default value
							defaultValueStr = fmt.Sprintf("%v", opt.DefaultValue)
						}
						sb.WriteString(fmt.Sprintf("	options.%s = %s\n", opt.Name, defaultValueStr))
					}
				case "*string":
					sb.WriteString(fmt.Sprintf("	options.%s = new(string)\n", opt.Name))
					if opt.DefaultValue != nil {
						if dvStr, ok := opt.DefaultValue.(string); ok {
							sb.WriteString(fmt.Sprintf("	*options.%s = %q\n", opt.Name, dvStr))
						}
						// If opt.DefaultValue is not nil AND not a string, we skip assignment, relying on new(string).
						// This avoids *options.X = <nil> if DefaultValue was, e.g., a nil pointer of another type.
					}
				case "*int":
					sb.WriteString(fmt.Sprintf("	options.%s = new(int)\n", opt.Name))
					if opt.DefaultValue != nil {
						if dvInt, ok := opt.DefaultValue.(int); ok {
							sb.WriteString(fmt.Sprintf("	*options.%s = %d\n", opt.Name, dvInt))
						}
					}
				case "*bool":
					sb.WriteString(fmt.Sprintf("	options.%s = new(bool)\n", opt.Name))
					if opt.DefaultValue != nil {
						if dvBool, ok := opt.DefaultValue.(bool); ok {
							sb.WriteString(fmt.Sprintf("	*options.%s = %t\n", opt.Name, dvBool))
						}
					}
				}
			}
		}

		// Environment variable processing
		sb.WriteString(`
	// 2. Override with environment variable values.
	// This section assumes 'options' is already initialized.
`)
		for _, opt := range cmdMeta.Options {
			if opt.EnvVar == "" {
				continue
			}
			sb.WriteString(fmt.Sprintf(`
	if val, ok := os.LookupEnv(%q); ok {
`, opt.EnvVar))
			if opt.IsTextUnmarshaler {
				if opt.IsPointer {
					sb.WriteString(fmt.Sprintf(`
		if options.%s == nil {
			options.%s = new(%s)
		}
		err := options.%s.UnmarshalText([]byte(val))
		if err != nil {
			slog.WarnContext(ctx, "Could not parse environment variable for TextUnmarshaler option; using default or previously set value.", "envVar", %q, "option", %q, "value", val, "error", err)
		}
`, opt.Name, opt.Name, strings.TrimPrefix(opt.TypeName, "*"), opt.Name, opt.EnvVar, opt.CliName))
				} else {
					sb.WriteString(fmt.Sprintf(`
		err := (&options.%s).UnmarshalText([]byte(val))
		if err != nil {
			slog.WarnContext(ctx, "Could not parse environment variable for TextUnmarshaler option; using default or previously set value.", "envVar", %q, "option", %q, "value", val, "error", err)
		}
`, opt.Name, opt.EnvVar, opt.CliName))
				}
			} else if opt.IsPointer && opt.UnderlyingKind == "string" {
				sb.WriteString(fmt.Sprintf(`
		typedVal := %s(val)
		options.%s = &typedVal
`, strings.TrimPrefix(opt.TypeName, "*"), opt.Name))
			} else if opt.UnderlyingKind == "string" {
				sb.WriteString(fmt.Sprintf(`
		options.%s = %s(val)
`, opt.Name, opt.TypeName))
			} else {
				switch opt.TypeName {
				case "string":
					sb.WriteString(fmt.Sprintf("		options.%s = val\n", opt.Name))
				case "int":
					sb.WriteString(fmt.Sprintf(`
		if v, err := strconv.Atoi(val); err == nil {
			options.%s = v
		} else {
			slog.WarnContext(ctx, "Could not parse environment variable as int for option", "envVar", %q, "option", %q, "value", val, "error", err)
		}
`, opt.Name, opt.EnvVar, opt.Name))
				case "bool":
					sb.WriteString(fmt.Sprintf(`
		if v, err := strconv.ParseBool(val); err == nil {
			options.%s = v
		} else {
			slog.WarnContext(ctx, "Could not parse environment variable as bool for option", "envVar", %q, "option", %q, "value", val, "error", err)
		}
`, opt.Name, opt.EnvVar, opt.Name))
				case "*string":
					sb.WriteString(fmt.Sprintf(`
		if options.%s == nil { options.%s = new(string) }
		*options.%s = val
`, opt.Name, opt.Name, opt.Name))
				case "*int":
					sb.WriteString(fmt.Sprintf(`
		if options.%s == nil { options.%s = new(int) }
		if v, err := strconv.Atoi(val); err == nil {
			*options.%s = v
		} else {
			slog.WarnContext(ctx, "Could not parse environment variable as *int for option", "envVar", %q, "option", %q, "value", val, "error", err)
		}
`, opt.Name, opt.Name, opt.Name, opt.EnvVar, opt.Name))
				case "*bool":
					sb.WriteString(fmt.Sprintf(`
		if options.%s == nil { options.%s = new(bool) }
		if v, err := strconv.ParseBool(val); err == nil {
			*options.%s = v
		} else {
			slog.WarnContext(ctx, "Could not parse environment variable as *bool for option", "envVar", %q, "option", %q, "value", val, "error", err)
		}
`, opt.Name, opt.Name, opt.Name, opt.EnvVar, opt.Name))
				case "[]string":
					sb.WriteString(fmt.Sprintf("		options.%s = strings.Split(val, \",\")\n", opt.Name))
				}
			}
			sb.WriteString("	}\n") // close if val, ok
		}

		// Flag setup
		sb.WriteString(`
	// 3. Set flags.
`)
		for _, opt := range cmdMeta.Options {
			kebabCaseName := stringutils.ToKebabCase(opt.Name)
			helpComment := ""
			if opt.DefaultValue != nil {
				// If there's a default value, always include "Original Default:"
				// and include "Env:" part, even if EnvVar is empty.
				helpComment = fmt.Sprintf("/* Original Default: %v, Env: %s */", opt.DefaultValue, opt.EnvVar)
			} else if opt.EnvVar != "" {
				// Only EnvVar is present
				helpComment = fmt.Sprintf("/* Env: %s */", opt.EnvVar)
			}
			// If neither DefaultValue nor EnvVar is present, helpComment remains ""

			switch opt.TypeName {
			case "string":
				sb.WriteString(fmt.Sprintf("	flag.StringVar(&options.%s, %q, options.%s, %s %s)\n", opt.Name, kebabCaseName, opt.Name, formatHelpText(opt.HelpText), helpComment))
			case "int":
				sb.WriteString(fmt.Sprintf("	flag.IntVar(&options.%s, %q, options.%s, %s %s)\n", opt.Name, kebabCaseName, opt.Name, formatHelpText(opt.HelpText), helpComment))
			case "bool":
				if opt.IsRequired && fmt.Sprintf("%v", opt.DefaultValue) == "true" {
					sb.WriteString(fmt.Sprintf("	var %s_NoFlagIsPresent bool\n", opt.Name))
					sb.WriteString(fmt.Sprintf("	flag.BoolVar(&%s_NoFlagIsPresent, \"no-%s\", false, %q)\n", opt.Name, kebabCaseName, "Set "+kebabCaseName+" to false"))
				} else {
					sb.WriteString(fmt.Sprintf("	flag.BoolVar(&options.%s, %q, options.%s, %s %s)\n", opt.Name, kebabCaseName, opt.Name, formatHelpText(opt.HelpText), helpComment))
				}
			case "*string":
				sb.WriteString(fmt.Sprintf("	is%sNilInitially := options.%s == nil\n", opt.Name, opt.Name))
				sb.WriteString(fmt.Sprintf("	var temp%sVal %s\n", opt.Name, strings.TrimPrefix(opt.TypeName, "*")))
				sb.WriteString(fmt.Sprintf("	var default%sValForFlag string\n", opt.Name))
				sb.WriteString(fmt.Sprintf("	if options.%s != nil { default%sValForFlag = *options.%s }\n", opt.Name, opt.Name, opt.Name))
				// Line removed: sb.WriteString(fmt.Sprintf("	if options.%s == nil { options.%s = new(string) }\n", opt.Name, opt.Name))
				sb.WriteString(fmt.Sprintf("	if is%sNilInitially {\n", opt.Name))
				sb.WriteString(fmt.Sprintf("		flag.StringVar(&temp%sVal, %q, \"\", %s %s)\n", opt.Name, kebabCaseName, formatHelpText(opt.HelpText), helpComment))
				sb.WriteString(fmt.Sprintf("	} else {\n"))
				sb.WriteString(fmt.Sprintf("		flag.StringVar(options.%s, %q, default%sValForFlag, %s %s)\n", opt.Name, kebabCaseName, opt.Name, formatHelpText(opt.HelpText), helpComment))
				sb.WriteString(fmt.Sprintf("	}\n"))
			case "*int":
				sb.WriteString(fmt.Sprintf("	is%sNilInitially := options.%s == nil\n", opt.Name, opt.Name))
				sb.WriteString(fmt.Sprintf("	var temp%sVal %s\n", opt.Name, strings.TrimPrefix(opt.TypeName, "*")))
				sb.WriteString(fmt.Sprintf("	var default%sValForFlag int\n", opt.Name))
				sb.WriteString(fmt.Sprintf("	if options.%s != nil { default%sValForFlag = *options.%s }\n", opt.Name, opt.Name, opt.Name))
				// Line removed: sb.WriteString(fmt.Sprintf("	if options.%s == nil { options.%s = new(int) }\n", opt.Name, opt.Name))
				sb.WriteString(fmt.Sprintf("	if is%sNilInitially {\n", opt.Name))
				sb.WriteString(fmt.Sprintf("		flag.IntVar(&temp%sVal, %q, 0, %s %s)\n", opt.Name, kebabCaseName, formatHelpText(opt.HelpText), helpComment))
				sb.WriteString(fmt.Sprintf("	} else {\n"))
				sb.WriteString(fmt.Sprintf("		flag.IntVar(options.%s, %q, default%sValForFlag, %s %s)\n", opt.Name, kebabCaseName, opt.Name, formatHelpText(opt.HelpText), helpComment))
				sb.WriteString(fmt.Sprintf("	}\n"))
			case "*bool":
				sb.WriteString(fmt.Sprintf("	is%sNilInitially := options.%s == nil\n", opt.Name, opt.Name))
				sb.WriteString(fmt.Sprintf("	var temp%sVal %s\n", opt.Name, strings.TrimPrefix(opt.TypeName, "*")))
				sb.WriteString(fmt.Sprintf("	var default%sValForFlag bool\n", opt.Name))
				sb.WriteString(fmt.Sprintf("	if options.%s != nil { default%sValForFlag = *options.%s }\n", opt.Name, opt.Name, opt.Name))
				// Line removed: sb.WriteString(fmt.Sprintf("	if options.%s == nil { options.%s = new(bool) }\n", opt.Name, opt.Name))
				sb.WriteString(fmt.Sprintf("	if is%sNilInitially {\n", opt.Name))
				sb.WriteString(fmt.Sprintf("		flag.BoolVar(&temp%sVal, %q, false, %s %s)\n", opt.Name, kebabCaseName, formatHelpText(opt.HelpText), helpComment))
				sb.WriteString(fmt.Sprintf("	} else {\n"))
				sb.WriteString(fmt.Sprintf("		flag.BoolVar(options.%s, %q, default%sValForFlag, %s %s)\n", opt.Name, kebabCaseName, opt.Name, formatHelpText(opt.HelpText), helpComment))
				sb.WriteString(fmt.Sprintf("	}\n"))
			default:
				if opt.IsTextUnmarshaler && opt.IsTextMarshaler {
					if opt.IsPointer {
						sb.WriteString(fmt.Sprintf("	is%sNilInitially := options.%s == nil\n", opt.Name, opt.Name))
						sb.WriteString(fmt.Sprintf("	var temp%sVal %s\n", opt.Name, strings.TrimPrefix(opt.TypeName, "*")))
						// Old block removed
						sb.WriteString(fmt.Sprintf("	if is%sNilInitially {\n", opt.Name))
						sb.WriteString(fmt.Sprintf("		flag.TextVar(&temp%sVal, %q, &temp%sVal, %s %s)\n", opt.Name, opt.CliName, opt.Name, formatHelpText(opt.HelpText), helpComment))
						sb.WriteString(fmt.Sprintf("	} else {\n"))
						sb.WriteString(fmt.Sprintf("		flag.TextVar(options.%s, %q, options.%s, %s %s)\n", opt.Name, opt.CliName, opt.Name, formatHelpText(opt.HelpText), helpComment))
						sb.WriteString(fmt.Sprintf("	}\n"))
					} else {
						sb.WriteString(fmt.Sprintf("	flag.TextVar(&options.%s, %q, options.%s, %s %s)\n", opt.Name, opt.CliName, opt.Name, formatHelpText(opt.HelpText), helpComment))
					}
				} else if opt.IsPointer && len(opt.EnumValues) > 0 && !opt.IsTextUnmarshaler {
					sb.WriteString(fmt.Sprintf(`
	if options.%s == nil {
		options.%s = new(%s)
	}
	flag.Var(options.%s, %q, %s)
`, opt.Name, opt.Name, strings.TrimPrefix(opt.TypeName, "*"), opt.Name, kebabCaseName, formatHelpText(opt.HelpText)))
				}
			}
		}

		sb.WriteString(`
	// 4. Parse.
	flag.Parse()
	flag.Visit(func(f *flag.Flag) { isFlagExplicitlySet[f.Name] = true })
`)
		for _, opt := range cmdMeta.Options {
			if opt.TypeName == "bool" && opt.IsRequired && fmt.Sprintf("%v", opt.DefaultValue) == "true" {
				sb.WriteString(fmt.Sprintf(`
	if %s_NoFlagIsPresent {
		options.%s = false
	}
`, opt.Name, opt.Name))
			}
		}

		sb.WriteString(`

	// 6. Assign values for initially nil pointers if flags were explicitly set
`)
		// This loop iterates through cmdMeta.Options to generate the assignment logic
		for _, opt := range cmdMeta.Options {
			flagKeyForCheck := ""
			isRelevantPointer := false

			if opt.IsPointer && opt.IsTextUnmarshaler {
				flagKeyForCheck = opt.CliName
				if flagKeyForCheck == "" { // Fallback if CliName was empty
					flagKeyForCheck = stringutils.ToKebabCase(opt.Name)
				}
				isRelevantPointer = true
			} else {
				switch opt.TypeName {
				case "*string", "*int", "*bool":
					flagKeyForCheck = stringutils.ToKebabCase(opt.Name)
					isRelevantPointer = true
				default:
					// Not a pointer type this logic handles
					isRelevantPointer = false // Explicitly
				}
			}

			if isRelevantPointer { // Check isRelevantPointer
				// Ensure is%sNilInitially and temp%sVal are in scope from flag setup
				sb.WriteString(fmt.Sprintf("	if is%sNilInitially && isFlagExplicitlySet[%q] {\n", opt.Name, flagKeyForCheck))
				sb.WriteString(fmt.Sprintf("		options.%s = &temp%sVal\n", opt.Name, opt.Name))
				sb.WriteString(fmt.Sprintf("	}\n"))
			}
		}

		sb.WriteString(`
	// 5. Perform required checks (excluding booleans).
`)
		for _, opt := range cmdMeta.Options {
			kebabCaseName := stringutils.ToKebabCase(opt.Name) // Define kebabCaseName at the top of the loop

			// Required check logic will be inserted here
			if opt.IsRequired && opt.TypeName == "string" {
				// kebabCaseName is already defined above
				defaultValStr := `""`
				if opt.DefaultValue != nil {
					if dv, ok := opt.DefaultValue.(string); ok {
						defaultValStr = fmt.Sprintf("%q", dv)
					} else { // Should not happen with correct metadata
						defaultValStr = fmt.Sprintf("%q", fmt.Sprintf("%v", opt.DefaultValue))
					}
				}
				sb.WriteString(fmt.Sprintf("\n	initialDefault%s := %s\n", opt.Name, defaultValStr))

				envVarWasSetVar := fmt.Sprintf("env%sWasSet", opt.Name)
				sb.WriteString(fmt.Sprintf("	%s := false\n", envVarWasSetVar))

				envVarLogIfPresent := ""
				if opt.EnvVar != "" {
					sb.WriteString(fmt.Sprintf("	if _, ok := os.LookupEnv(%q); ok { %s = true }\n", opt.EnvVar, envVarWasSetVar))
					envVarLogIfPresent = fmt.Sprintf(`, "envVar", %q`, opt.EnvVar)
				}

				condition := fmt.Sprintf("options.%s == initialDefault%s && !isFlagExplicitlySet[%q] && !%s",
					opt.Name, opt.Name, kebabCaseName, envVarWasSetVar)

				sb.WriteString(fmt.Sprintf("	if %s {\n", condition))
				sb.WriteString(fmt.Sprintf("		slog.ErrorContext(ctx, \"Missing required flag or environment variable not set\", errors.New(\"Missing required flag or environment variable not set\"), \"flag\", %q%s, \"option\", %q)\n",
					kebabCaseName, envVarLogIfPresent, opt.Name))
				sb.WriteString("		os.Exit(1)\n")
				sb.WriteString("	}\n")
			} else if opt.IsRequired && opt.TypeName == "int" {
				kebabCaseName := stringutils.ToKebabCase(opt.Name) // Already defined at top of loop, but ensure it's used if this block was separate

				defaultValStr := "0"
				if opt.DefaultValue != nil {
					if dv, ok := opt.DefaultValue.(int); ok {
						defaultValStr = fmt.Sprintf("%d", dv)
					} else { // Should not happen
						defaultValStr = fmt.Sprintf("%v", opt.DefaultValue)
					}
				}
				sb.WriteString(fmt.Sprintf("\n	initialDefault%s := %s\n", opt.Name, defaultValStr))

				envVarWasSetVar := fmt.Sprintf("env%sWasSet", opt.Name)
				sb.WriteString(fmt.Sprintf("	%s := false\n", envVarWasSetVar))

				envVarLogIfPresent := ""
				if opt.EnvVar != "" {
					sb.WriteString(fmt.Sprintf("	if _, ok := os.LookupEnv(%q); ok { %s = true }\n", opt.EnvVar, envVarWasSetVar))
					envVarLogIfPresent = fmt.Sprintf(`, "envVar", %q`, opt.EnvVar)
				}

				condition := fmt.Sprintf("options.%s == initialDefault%s && !isFlagExplicitlySet[%q] && !%s",
					opt.Name, opt.Name, kebabCaseName, envVarWasSetVar)

				sb.WriteString(fmt.Sprintf("	if %s {\n", condition))
				sb.WriteString(fmt.Sprintf("		slog.ErrorContext(ctx, \"Missing required flag or environment variable not set\", errors.New(\"Missing required flag or environment variable not set\"), \"flag\", %q%s, \"option\", %q)\n",
					kebabCaseName, envVarLogIfPresent, opt.Name))
				sb.WriteString("		os.Exit(1)\n")
				sb.WriteString("	}\n")
			} else if opt.IsRequired && opt.TypeName == "*string" {
				kebabCaseName := stringutils.ToKebabCase(opt.Name)
				envVarWasSetVar := fmt.Sprintf("env%sWasSet", opt.Name)
				envVarLogIfPresent := ""

				sb.WriteString(fmt.Sprintf("	%s := false\n", envVarWasSetVar))
				if opt.EnvVar != "" {
					sb.WriteString(fmt.Sprintf("	if _, ok := os.LookupEnv(%q); ok { %s = true }\n", opt.EnvVar, envVarWasSetVar))
					envVarLogIfPresent = fmt.Sprintf(`, "envVar", %q`, opt.EnvVar)
				}

				sb.WriteString(fmt.Sprintf(`
	if !isFlagExplicitlySet[%q] && !%s { // If not set by flag or env
`, kebabCaseName, envVarWasSetVar))
				if opt.DefaultValue == nil { // No default value from struct tag
					sb.WriteString(fmt.Sprintf(`
		if options.%s == nil || *options.%s == "" {
			slog.ErrorContext(ctx, "Missing required flag or environment variable, and no default provided", errors.New("Missing required flag or environment variable, and no default provided"), "flag", %q%s, "option", %q)
			os.Exit(1)
		}
`, opt.Name, opt.Name, kebabCaseName, envVarLogIfPresent, opt.Name))
				} else {
					// If DefaultValue IS present, it's assumed to be set during options initialization.
					// The original template implicitly means if a default tag exists, the field is "provided" unless overridden.
					// So, if not set by flag/env, and a default tag was there, it's fine.
				}
				sb.WriteString(fmt.Sprintf(`
	} else if options.%s == nil || *options.%s == "" { // Explicitly set (by flag or env) to empty or nil
		slog.ErrorContext(ctx, "Required flag was set to an empty value", errors.New("Required flag was set to an empty value"), "flag", %q%s, "option", %q)
		os.Exit(1)
	}
`, opt.Name, opt.Name, kebabCaseName, envVarLogIfPresent, opt.Name))

			} else if opt.IsRequired && opt.TypeName == "*int" {
				kebabCaseName := stringutils.ToKebabCase(opt.Name)
				envVarWasSetVar := fmt.Sprintf("env%sWasSet", opt.Name)
				envVarLogIfPresent := ""

				sb.WriteString(fmt.Sprintf("	%s := false\n", envVarWasSetVar))
				if opt.EnvVar != "" {
					sb.WriteString(fmt.Sprintf("	if _, ok := os.LookupEnv(%q); ok { %s = true }\n", opt.EnvVar, envVarWasSetVar))
					envVarLogIfPresent = fmt.Sprintf(`, "envVar", %q`, opt.EnvVar)
				}

				sb.WriteString(fmt.Sprintf(`
	if !isFlagExplicitlySet[%q] && !%s { // If not set by flag or env
`, kebabCaseName, envVarWasSetVar))
				if opt.DefaultValue == nil { // No default value from struct tag
					sb.WriteString(fmt.Sprintf(`
		if options.%s == nil { // For *int, just being nil is enough if no default tag
			slog.ErrorContext(ctx, "Missing required flag or environment variable, and no default provided", errors.New("Missing required flag or environment variable, and no default provided"), "flag", %q%s, "option", %q)
			os.Exit(1)
		}
`, opt.Name, kebabCaseName, envVarLogIfPresent, opt.Name))
				}
				sb.WriteString(fmt.Sprintf(`
	} else if options.%s == nil { // Explicitly set (by flag or env) to nil
		slog.ErrorContext(ctx, "Required flag was not provided or set to nil", errors.New("Required flag was not provided or set to nil"), "flag", %q%s, "option", %q)
		os.Exit(1)
	}
`, opt.Name, kebabCaseName, envVarLogIfPresent, opt.Name))

			} else if opt.IsRequired {
				// Placeholder for other required types like *bool
				// sb.WriteString(fmt.Sprintf("\n	// TODO: Add required check for %s (type %s)\n", opt.Name, opt.TypeName))
			}

			// Enum validation (currently to be implemented in a future step)
			effectiveEnums := GetEffectiveEnumValues(opt)
			if len(effectiveEnums) > 0 {
				// sb.WriteString(fmt.Sprintf("\n	// TODO: Add enum validation for %s\n", opt.Name))
				allowedChoicesStr := make([]string, len(effectiveEnums))
				for i, e := range effectiveEnums {
					allowedChoicesStr[i] = fmt.Sprintf("%q", e)
				}
				sb.WriteString(fmt.Sprintf(`
	isValidChoice_%s := false
	allowedChoices_%s := []string{%s}
`, opt.Name, opt.Name, strings.Join(allowedChoicesStr, ", ")))

				pointerCheckPrefix := ""
				pointerCheckSuffix := ""
				// isPointerBasicType := false // Removed
				if opt.IsPointer {
					switch opt.TypeName {
					case "*string", "*int", "*bool":
						// isPointerBasicType = true // Removed
						currentValueStrVar := fmt.Sprintf("currentValue_%sStr", opt.Name)
						allowedChoicesVar := fmt.Sprintf("allowedChoices_%s", opt.Name)
						isValidChoiceVar := fmt.Sprintf("isValidChoice_%s", opt.Name)
						pointerCheckPrefix = fmt.Sprintf(`
	if options.%s != nil {
		%s := fmt.Sprintf("%%%%v", *options.%s)
		%s = slices.Contains(%s, %s)
	} else {
`, opt.Name, currentValueStrVar, opt.Name, isValidChoiceVar, allowedChoicesVar, currentValueStrVar)
					default:
						currentValueStrVar := fmt.Sprintf("currentValue_%sStr", opt.Name)
						allowedChoicesVar := fmt.Sprintf("allowedChoices_%s", opt.Name)
						isValidChoiceVar := fmt.Sprintf("isValidChoice_%s", opt.Name)
						pointerCheckPrefix = fmt.Sprintf(`
	if options.%s != nil {
		%s := fmt.Sprintf("%%%%v", *options.%s)
		%s = slices.Contains(%s, %s)
	} else { // Field is nil
`, opt.Name, currentValueStrVar, opt.Name, isValidChoiceVar, allowedChoicesVar, currentValueStrVar)
					}
					if opt.IsRequired {
						pointerCheckSuffix = fmt.Sprintf(`
		slog.ErrorContext(ctx, "Required enum flag is nil", errors.New("Required enum flag is nil"), "flag", %q, "option", %q)
		os.Exit(1)
	}
`, kebabCaseName, opt.Name)
					} else {
						pointerCheckSuffix = `
		isValidChoice_` + opt.Name + ` = true
	}
`
					}
					sb.WriteString(pointerCheckPrefix + pointerCheckSuffix)
				} else { // Non-pointer type
					currentValueStrVar := fmt.Sprintf("currentValue_%sStr", opt.Name)
					isValidChoiceVar := fmt.Sprintf("isValidChoice_%s", opt.Name)
					allowedChoicesVar := fmt.Sprintf("allowedChoices_%s", opt.Name)
					escapedOptName := strings.ReplaceAll(opt.Name, "%", "%%") // Escape % in opt.Name for options.%s

					sb.WriteString(fmt.Sprintf("\n\t%s := fmt.Sprintf(\"%%v\", options.%s)\n\t%s = slices.Contains(%s, %s)\n", // Corrected: %%%%v to %%v
						currentValueStrVar,
						escapedOptName, // Use escaped opt.Name here
						isValidChoiceVar,
						allowedChoicesVar,
						currentValueStrVar,
					))
				}

				// Invalid choice message generation
				kebabCaseName := stringutils.ToKebabCase(opt.Name) // Ensure kebabCaseName is available
				currentValueForMsgAccessor := fmt.Sprintf("options.%s", opt.Name)

				if opt.IsPointer { // Covers all pointer types including basic and custom enum pointers
					// currentValueForMsgAccessor is options.OptName (pointer itself)
					slogLineFormat := `slog.ErrorContext(ctx, "Invalid value for flag", errors.New("Invalid value for flag"), "flag", %q, "value", currentValueForMsg, "allowedChoices", strings.Join(allowedChoices_%s, ", "))`
					slogLine := fmt.Sprintf(slogLineFormat, kebabCaseName, opt.Name)

					sb.WriteString(fmt.Sprintf(`
	if !isValidChoice_%s {
		var currentValueForMsg interface{} = %s
		if options.%s != nil {
			currentValueForMsg = *options.%s
		}
		%s
		os.Exit(1)
	}
`, opt.Name, currentValueForMsgAccessor, opt.Name, opt.Name, slogLine))
				} else { // Non-pointer enum
					sb.WriteString(fmt.Sprintf(`
	if !isValidChoice_%s {
		var currentValueForMsg interface{} = %s // options.OptName
		slog.ErrorContext(ctx, "Invalid value for flag", errors.New("Invalid value for flag"), "flag", %q, "value", currentValueForMsg, "allowedChoices", strings.Join(allowedChoices_%s, ", "))
		os.Exit(1)
	}
`, opt.Name, currentValueForMsgAccessor, kebabCaseName, opt.Name))
				}
			}
		}
	}

	runFuncCall := ""
	if cmdMeta.RunFunc.ContextArgName != "" {
		if cmdMeta.RunFunc.OptionsArgTypeNameStripped != "" {
			optionsAccessor := "options"
			if !cmdMeta.RunFunc.OptionsArgIsPointer {
				optionsAccessor = "*options"
			}
			runFuncCall = fmt.Sprintf("err = %s(ctx, %s)", cmdMeta.RunFunc.Name, optionsAccessor)
		} else {
			runFuncCall = fmt.Sprintf("err = %s(ctx)", cmdMeta.RunFunc.Name)
		}
	} else {
		if cmdMeta.RunFunc.OptionsArgTypeNameStripped != "" {
			optionsAccessor := "options"
			if !cmdMeta.RunFunc.OptionsArgIsPointer {
				optionsAccessor = "*options"
			}
			runFuncCall = fmt.Sprintf("err = %s(%s)", cmdMeta.RunFunc.Name, optionsAccessor)
		} else {
			runFuncCall = fmt.Sprintf("err = %s()", cmdMeta.RunFunc.Name)
		}
	}
	// The \n was removed from the format string as the if statement will be on the same line.
	// The duplicated "err =" is removed from the line below.
	sb.WriteString(fmt.Sprintf("	if err := %s; err != nil {\n", strings.TrimPrefix(runFuncCall, "err = ")))

	sb.WriteString(`
		slog.ErrorContext(ctx, "Runtime error", "error", err)
		os.Exit(1)
	}
}
`)
	return sb.String(), nil
}

// Ternary is a helper function to mimic ternary operator for string selection
func Ternary(condition bool, trueVal, falseVal string) string {
	if condition {
		return trueVal
	}
	return falseVal
}

func GenerateMain(cmdMeta *metadata.CommandMetadata, helpText string, generateFullFile bool) (string, error) {
	if len(cmdMeta.Options) > 0 && cmdMeta.RunFunc.OptionsArgTypeNameStripped == "" {
		return "", fmt.Errorf("OptionsArgTypeNameStripped is empty for command %s, but options are present. This indicates an issue with parsing the run function's options struct type", cmdMeta.Name)
	}

	mainContent, err := generateMainContent(cmdMeta, helpText)
	if err != nil {
		return "", fmt.Errorf("generating main function content: %w", err)
	}

	if generateFullFile {
		// Construct the full Go source file content
		var sb strings.Builder
		sb.WriteString("package main\n\n")
		sb.WriteString("import (\n")

		// Standard imports - text/template and bytes are removed
		stdImports := []string{
			"context",  // Likely needed by generated code
			"errors",   // Likely needed by generated code for error handling
			"flag",     // Essential for CLI flag parsing
			"fmt",      // For printing help text, potentially errors
			"os",       // For os.Stderr, os.Exit, os.LookupEnv
			"slices",   // For enum validation if used
			"strconv",  // For parsing env vars to int/bool
			"strings",  // For string manipulations (TrimPrefix, Split)
			"log/slog", // For logging
		}
		// stringutils is used by the generator (e.g. ToKebabCase), not directly in the generated main.

		for _, importPath := range stdImports {
			sb.WriteString(fmt.Sprintf("\t%q\n", importPath))
		}
		sb.WriteString(")\n\n")
		sb.WriteString(mainContent)
		return sb.String(), nil
	}
	return mainContent, nil
}
