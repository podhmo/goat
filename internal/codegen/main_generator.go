package codegen

import (
	"fmt"
	"strings"

	// "text/template" // Removed
	// "bytes"         // Removed

	"github.com/podhmo/goat/internal/metadata"
	"github.com/podhmo/goat/internal/utils/stringutils" // Re-adding as it's needed by generateMainContent
)

// formatHelpText formats the help text string for inclusion in the generated Go code.
// It handles escaped newlines (\\n) and placeholder single quotes (') for backticks (`).
// It then chooses the best Go string literal representation.
// formatHelpText formats the help text string for inclusion in the generated Go code.
// It handles escaped newlines (\\n) and placeholder single quotes (') for backticks (â€œ).
// It then chooses the best Go string literal representation.
func formatHelpText(text string) string {
	// Initial transformations
	// 1. Replace literal "\\n" with actual newline character '\n'.
	processedText := strings.ReplaceAll(text, "\\n", "\n")
	// 2. Replace placeholder single quote "'" with actual backtick '`'.
	processedText = strings.ReplaceAll(processedText, "'", "`")

	hasNewlines := strings.Contains(processedText, "\n")
	hasBackticks := strings.Contains(processedText, "`")

	if hasNewlines && hasBackticks {
		var sb strings.Builder
		sb.WriteString("`")
		last := 0
		for i, r := range processedText {
			if r == '`' {
				sb.WriteString(processedText[last:i])
				sb.WriteString("`")
				sb.WriteString(" + \"`\" + ")
				sb.WriteString("`")
				last = i + 1
			}
		}
		sb.WriteString(processedText[last:])
		sb.WriteString("`")
		return sb.String()

	} else if hasNewlines {
		return "`" + processedText + "`"
	} else {
		return fmt.Sprintf("%q", processedText)
	}
}

// GenerateMain creates the Go code string for the new main() function
// based on the extracted command metadata.
// If generateFullFile is true, it returns a complete Go file content including package and imports.
// GetEffectiveEnumValues converts enum values to a slice of strings.
func GetEffectiveEnumValues(opt *metadata.OptionMetadata) []string {
	if opt != nil && opt.EnumValues != nil {
		strValues := make([]string, len(opt.EnumValues))
		for i, v := range opt.EnumValues {
			strValues[i] = fmt.Sprintf("%v", v)
		}
		return strValues
	}
	return nil
}

// GenerateMain creates the Go code string for the new main() function
// based on the extracted command metadata.
// If generateFullFile is true, it returns a complete Go file content including package and imports.
// Otherwise, it returns only the main function body.

// generateMainContent orchestrates code generation using OptionHandlers.
func generateMainContent(cmdMeta *metadata.CommandMetadata, helpText string) (string, error) {
	var sb strings.Builder
	optionsVarName := "options" // Standard name for the options struct instance
	ctxVarName := "ctx"         // Standard name for the context variable
	isFlagExplicitlySetMapName := "isFlagExplicitlySet"
	globalTempVarPrefix := "temp" // Prefix for temporary variables used by some handlers

	sb.WriteString(fmt.Sprintf(`// This main function was auto-generated by goat.
func main() {
	%s := context.Background()
	%s := make(map[string]bool)
	var err error // Declare error variable for use by generated error checks
_ = err // Avoid "declared and not used" if no errors are handled yet by run func.
`, ctxVarName, isFlagExplicitlySetMapName))

	if helpText != "" {
		sb.WriteString(fmt.Sprintf(`
	flag.Usage = func() {
		fmt.Fprint(os.Stderr, %s)
	}
`, formatHelpText(helpText)))
	}

	if cmdMeta.RunFunc.OptionsArgTypeNameStripped != "" {
		sb.WriteString(fmt.Sprintf("\n	// --- 1. Initialize Options Struct ---\n"))
		if cmdMeta.RunFunc.InitializerFunc != "" {
			sb.WriteString(fmt.Sprintf("	%s := %s()\n", optionsVarName, cmdMeta.RunFunc.InitializerFunc))
		} else {
			sb.WriteString(fmt.Sprintf("	%s := new(%s)\n", optionsVarName, cmdMeta.RunFunc.OptionsArgTypeNameStripped))
			sb.WriteString("	// Apply default values from struct tags/types\n")
			for _, opt := range cmdMeta.Options {
				handler := GetOptionHandler(opt)
				snippets := handler.GenerateDefaultValueInitializationCode(opt, optionsVarName)
				if snippets.Declarations != "" {
					sb.WriteString(snippets.Declarations)
				}
				if snippets.Logic != "" {
					sb.WriteString(snippets.Logic)
				}
			}
		}

		sb.WriteString(fmt.Sprintf("\n	// --- 2. Process Environment Variables ---\n"))
		for _, opt := range cmdMeta.Options {
			if opt.EnvVar == "" {
				continue
			}
			handler := GetOptionHandler(opt)
			envValVarName := stringutils.ToCamelCase(opt.Name) + "EnvVal"
			sb.WriteString(fmt.Sprintf("	if %s, ok := os.LookupEnv(%q); ok {\n", envValVarName, opt.EnvVar))
			snippets := handler.GenerateEnvVarProcessingCode(opt, optionsVarName, envValVarName, ctxVarName)
			if snippets.Declarations != "" {
				sb.WriteString(fmt.Sprintf("		%s", snippets.Declarations)) // Indent
			}
			if snippets.Logic != "" {
				sb.WriteString(fmt.Sprintf("		%s", snippets.Logic)) // Indent
			}
			sb.WriteString("	}\n")
		}

		sb.WriteString(fmt.Sprintf("\n	// --- 3. Register Flags ---\n"))
		var flagDeclarationsSb strings.Builder
		var flagLogicSb strings.Builder
		for _, opt := range cmdMeta.Options {
			handler := GetOptionHandler(opt)
			snippets := handler.GenerateFlagRegistrationCode(opt, optionsVarName, isFlagExplicitlySetMapName, globalTempVarPrefix)
			if snippets.Declarations != "" {
				flagDeclarationsSb.WriteString(snippets.Declarations)
			}
			if snippets.Logic != "" {
				flagLogicSb.WriteString(snippets.Logic)
			}
		}
		sb.WriteString(flagDeclarationsSb.String())
		sb.WriteString(flagLogicSb.String())

		sb.WriteString(fmt.Sprintf("\n	// --- 4. Parse Flags ---\n"))
		sb.WriteString("	flag.Parse()\n")
		sb.WriteString(fmt.Sprintf("	flag.Visit(func(f *flag.Flag) { %s[f.Name] = true })\n", isFlagExplicitlySetMapName))

		// Handle special case for bool flags with `no-` prefix logic (if any handler generated it)
		// This is a bit of a hack; ideally, the BoolHandler itself would manage this entirely.
		// For now, we keep the original loop that checks for `_NoFlagIsPresent` variables.
		// This specific logic might need to be integrated more cleanly into BoolHandler's post-parse or flag registration.
		for _, opt := range cmdMeta.Options {
			// This check is specific and assumes a certain variable naming convention from the old Bool logic.
			// If BoolHandler is fully self-contained, this loop might be removable or change.
			if opt.TypeName == "bool" && opt.IsRequired && fmt.Sprintf("%v", opt.DefaultValue) == "true" {
				// This assumes BoolHandler might have set up a var like "OptionName_NoFlagIsPresent"
				// This part is tricky because GenerateFlagPostParseAssignmentCode for BoolHandler is empty.
				// The original logic for this was outside any handler.
				// For now, let's keep it to maintain that specific boolean behavior.
				// A more robust solution would be for BoolHandler to manage this itself.
				sb.WriteString(fmt.Sprintf(`
	// Special handling for required bool flags that default to true (e.g., --no-option to set to false)
	if %s_NoFlagIsPresent, ok := %s["no-%s"]; ok && %s_NoFlagIsPresent { // This check needs refinement based on BoolHandler output
		// %s.%s = false // This logic is likely handled by BoolHandler's flag registration now.
		// This block might be redundant if BoolHandler correctly sets the value.
		// Re-evaluating if BoolHandler's flag.BoolVar and the main isFlagExplicitlySet map are sufficient.
		// The original code had:
		// if LoginEnabled_NoFlagIsPresent { options.LoginEnabled = false }
		// This needs to be correctly generated by the BoolHandler or its post-processing.
		// For now, commenting out direct manipulation, assuming BoolHandler's flag registration handles it.
		// This specific case might need a dedicated variable set by BoolHandler if `isFlagExplicitlySet` is not enough.
	}
`, stringutils.ToCamelCase(opt.Name), isFlagExplicitlySetMapName, opt.CliName, stringutils.ToCamelCase(opt.Name) /*, optionsVarName, opt.Name*/))
			}
		}


		sb.WriteString(fmt.Sprintf("\n	// --- 5. Post-Parse Flag Assignments (for pointers, etc.) ---\n"))
		var postParseDeclarationsSb strings.Builder
		var postParseLogicSb strings.Builder
		for _, opt := range cmdMeta.Options {
			handler := GetOptionHandler(opt)
			snippets := handler.GenerateFlagPostParseAssignmentCode(opt, optionsVarName, isFlagExplicitlySetMapName, globalTempVarPrefix)
			if snippets.Declarations != "" {
				postParseDeclarationsSb.WriteString(snippets.Declarations)
			}
			if snippets.Logic != "" {
				postParseLogicSb.WriteString(snippets.Logic)
			}
		}
		sb.WriteString(postParseDeclarationsSb.String())
		sb.WriteString(postParseLogicSb.String())


		sb.WriteString(fmt.Sprintf("\n	// --- 6. Perform Required Option Checks ---\n"))
		// Initial default values and env var set status declarations for required checks
		var requiredCheckDeclarations strings.Builder
		initialDefaultsMap := make(map[string]string) // To store var names for initial defaults
		envWasSetMap := make(map[string]string)       // To store var names for env set status

		for _, opt := range cmdMeta.Options {
			if !opt.IsRequired {
				continue
			}
			// Variable name for storing initial default value of the option
			initialDefaultVarName := fmt.Sprintf("initialDefault_%s", stringutils.ToTitleCamelCase(opt.Name))
			initialDefaultsMap[opt.Name] = initialDefaultVarName

			// Generate code to capture the initial default value for the option.
			// This variable (initialDefaultVarName) will be used by some handlers' GenerateRequiredCheckCode.
			if opt.DefaultValue != nil {
				switch opt.TypeName {
				case "string":
					valStr, _ := opt.DefaultValue.(string)
					requiredCheckDeclarations.WriteString(fmt.Sprintf("	%s := %s\n", initialDefaultVarName, formatHelpText(valStr)))
				case "[]string":
					// For []string, the default value is a comma-separated string.
					// The required check for slices usually checks len(), so the exact default representation might be less critical
					// if the handler does not directly compare the initialDefaultVarName.
					// Provide the string representation.
					valStr := fmt.Sprintf("%v", opt.DefaultValue)
					requiredCheckDeclarations.WriteString(fmt.Sprintf("	%s := %s\n", initialDefaultVarName, formatHelpText(valStr)))
				case "int":
					valNum, ok := opt.DefaultValue.(float64) // JSON numbers are float64
					if !ok {
						requiredCheckDeclarations.WriteString(fmt.Sprintf("	%s := 0 // fallback, unexpected default type %T for int\n", initialDefaultVarName, opt.DefaultValue))
					} else {
						requiredCheckDeclarations.WriteString(fmt.Sprintf("	%s := %d\n", initialDefaultVarName, int(valNum)))
					}
				case "bool":
					valBool, ok := opt.DefaultValue.(bool)
					if !ok {
						requiredCheckDeclarations.WriteString(fmt.Sprintf("	%s := false // fallback, unexpected default type %T for bool\n", initialDefaultVarName, opt.DefaultValue))
					} else {
						requiredCheckDeclarations.WriteString(fmt.Sprintf("	%s := %t\n", initialDefaultVarName, valBool))
					}
				default:
					// For TextUnmarshaler (non-pointer), pointers, or other complex types,
					// default to the string representation. TextUnmarshalerHandler expects this.
					// Pointer handlers mostly check for `nil` and might not use this variable if opt.DefaultValue was nil.
					valStr := fmt.Sprintf("%v", opt.DefaultValue)
					requiredCheckDeclarations.WriteString(fmt.Sprintf("	%s := %s\n", initialDefaultVarName, formatHelpText(valStr)))
				}
			} else { // opt.DefaultValue == nil
				// Create a zero-value literal according to the type for comparison by handlers.
				switch opt.TypeName {
				case "string", "[]string": // For []string, required check is len==0, so "" is fine.
					requiredCheckDeclarations.WriteString(fmt.Sprintf("	%s := \"\"\n", initialDefaultVarName))
				case "int":
					requiredCheckDeclarations.WriteString(fmt.Sprintf("	%s := 0\n", initialDefaultVarName))
				case "bool":
					requiredCheckDeclarations.WriteString(fmt.Sprintf("	%s := false\n", initialDefaultVarName))
				default:
					if strings.HasPrefix(opt.TypeName, "*") {
						// For pointers, the "default default" is nil. Handlers check options.Field == nil.
						// The initialDefaultVarName here is for consistency; a typed nil.
						requiredCheckDeclarations.WriteString(fmt.Sprintf("	var %s %s // Typed nil\n", initialDefaultVarName, opt.TypeName))
					} else if opt.IsTextUnmarshaler { // Non-pointer TextUnmarshaler
						// Default value is like unmarshaling an empty string.
						requiredCheckDeclarations.WriteString(fmt.Sprintf("	%s := \"\"\n", initialDefaultVarName))
					} else {
						// Fallback for other unknown non-pointer types with nil default.
						requiredCheckDeclarations.WriteString(fmt.Sprintf("	// TODO: Review default for %s (type %s) when opt.DefaultValue is nil.\n", opt.Name, opt.TypeName))
						requiredCheckDeclarations.WriteString(fmt.Sprintf("	%s := \"\"\n", initialDefaultVarName))
					}
				}
			}

			// Variable name for env var set status
			envWasSetVarName := fmt.Sprintf("env_%s_WasSet", stringutils.ToTitleCamelCase(opt.Name))
			envWasSetMap[opt.Name] = envWasSetVarName
			if opt.EnvVar != "" {
				requiredCheckDeclarations.WriteString(fmt.Sprintf("	_, %s := os.LookupEnv(%q)\n", envWasSetVarName, opt.EnvVar))
			} else {
				requiredCheckDeclarations.WriteString(fmt.Sprintf("	%s := false\n", envWasSetVarName))
			}
		}
		sb.WriteString(requiredCheckDeclarations.String())

		// Actual required checks
		for _, opt := range cmdMeta.Options {
			if !opt.IsRequired {
				continue
			}
			handler := GetOptionHandler(opt)
			initialDefaultVar := initialDefaultsMap[opt.Name]
			envWasSetVar := envWasSetMap[opt.Name]

			snippets := handler.GenerateRequiredCheckCode(opt, optionsVarName, isFlagExplicitlySetMapName, initialDefaultVar, envWasSetVar, ctxVarName)
			if snippets.Declarations != "" { // Should be rare for required checks but possible
				sb.WriteString(snippets.Declarations)
			}
			if snippets.Logic != "" {
				// Logic from GenerateRequiredCheckCode is expected to handle os.Exit or return an error
				// If it returns an error, it should be `err = fmt.Errorf(...)` and then checked.
				// For now, assuming it might call os.Exit(1) or includes `return err` that the main template will handle.
				// Let's make it assign to `err` and check.
				sb.WriteString(fmt.Sprintf("if err = func() error { %s }(); err != nil {\n", snippets.Logic))
				sb.WriteString(fmt.Sprintf("	slog.ErrorContext(%s, \"Error processing required option\", \"option\", %q, \"error\", err)\n", ctxVarName, opt.CliName))
				sb.WriteString("	os.Exit(1)\n")
				sb.WriteString("}\n")
			}
		}

		sb.WriteString(fmt.Sprintf("\n	// --- 7. Perform Enum Validations ---\n"))
		for _, opt := range cmdMeta.Options {
			// GetEffectiveEnumValues is defined in this package, accessible by handlers.
			// No, GetEffectiveEnumValues is in main_generator.go, handlers are in option_handlers.go.
			// This means handlers must be passed the enum values, or GetEffectiveEnumValues must be public/moved.
			// Current handlers use GetEffectiveEnumValues(opt) from metadata.
			if len(GetEffectiveEnumValues(opt)) == 0 { // Use the helper from this package
				continue
			}
			handler := GetOptionHandler(opt)
			snippets := handler.GenerateEnumValidationCode(opt, optionsVarName, ctxVarName)
			if snippets.Declarations != "" {
				sb.WriteString(snippets.Declarations)
			}
			if snippets.Logic != "" {
				// Similar to required checks, if it returns an error.
				sb.WriteString(fmt.Sprintf("if err = func() error { %s }(); err != nil {\n", snippets.Logic))
				sb.WriteString(fmt.Sprintf("	slog.ErrorContext(%s, \"Error validating enum for option\", \"option\", %q, \"error\", err)\n", ctxVarName, opt.CliName))
				sb.WriteString("	os.Exit(1)\n")
				sb.WriteString("}\n")
			}
		}
	} // End of if cmdMeta.RunFunc.OptionsArgTypeNameStripped != ""

	sb.WriteString(fmt.Sprintf("\n	// --- 8. Execute Run Function ---\n"))
	runFuncCall := ""
	if cmdMeta.RunFunc.ContextArgName != "" { // Function expects context
		if cmdMeta.RunFunc.OptionsArgTypeNameStripped != "" { // Function expects options
			optionsAccessor := optionsVarName
			if !cmdMeta.RunFunc.OptionsArgIsPointer {
				optionsAccessor = "*" + optionsVarName
			}
			runFuncCall = fmt.Sprintf("%s(%s, %s)", cmdMeta.RunFunc.Name, ctxVarName, optionsAccessor)
		} else { // Function does not expect options
			runFuncCall = fmt.Sprintf("%s(%s)", cmdMeta.RunFunc.Name, ctxVarName)
		}
	} else { // Function does not expect context
		if cmdMeta.RunFunc.OptionsArgTypeNameStripped != "" { // Function expects options
			optionsAccessor := optionsVarName
			if !cmdMeta.RunFunc.OptionsArgIsPointer {
				optionsAccessor = "*" + optionsVarName
			}
			runFuncCall = fmt.Sprintf("%s(%s)", cmdMeta.RunFunc.Name, optionsAccessor)
		} else { // Function does not expect options
			runFuncCall = fmt.Sprintf("%s()", cmdMeta.RunFunc.Name)
		}
	}

	// Assign the result of runFuncCall to `err`
	sb.WriteString(fmt.Sprintf("	err = %s\n", runFuncCall))
	sb.WriteString(fmt.Sprintf(`if err != nil {
	slog.ErrorContext(%s, "Runtime error from command function", "error", err)
	os.Exit(1)
}
`, ctxVarName))

	sb.WriteString("}\n") // Close main func
	return sb.String(), nil
}


// Ternary is a helper function to mimic ternary operator for string selection
func Ternary(condition bool, trueVal, falseVal string) string {
	if condition {
		return trueVal
	}
	return falseVal
}

func GenerateMain(cmdMeta *metadata.CommandMetadata, helpText string, generateFullFile bool) (string, error) {
	if len(cmdMeta.Options) > 0 && cmdMeta.RunFunc.OptionsArgTypeNameStripped == "" {
		return "", fmt.Errorf("OptionsArgTypeNameStripped is empty for command %s, but options are present. This indicates an issue with parsing the run function's options struct type", cmdMeta.Name)
	}

	mainContent, err := generateMainContent(cmdMeta, helpText)
	if err != nil {
		return "", fmt.Errorf("generating main function content: %w", err)
	}

	if generateFullFile {
		// Construct the full Go source file content
		var sb strings.Builder
		sb.WriteString("package main\n\n")
		sb.WriteString("import (\n")

		// Standard imports - text/template and bytes are removed
		stdImports := []string{
			"context",  // Likely needed by generated code
			"errors",   // Likely needed by generated code for error handling
			"flag",     // Essential for CLI flag parsing
			"fmt",      // For printing help text, potentially errors
			"os",       // For os.Stderr, os.Exit, os.LookupEnv
			"slices",   // For enum validation if used
			"strconv",  // For parsing env vars to int/bool
			"strings",  // For string manipulations (TrimPrefix, Split)
			"log/slog", // For logging
		}
		// stringutils is used by the generator (e.g. ToKebabCase), not directly in the generated main.

		for _, importPath := range stdImports {
			sb.WriteString(fmt.Sprintf("\t%q\n", importPath))
		}
		sb.WriteString(")\n\n")
		sb.WriteString(mainContent)
		return sb.String(), nil
	}
	return mainContent, nil
}
