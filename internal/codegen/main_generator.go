package codegen

import (
	"fmt"
	"strings"

	"github.com/podhmo/goat/internal/metadata"
	"github.com/podhmo/goat/internal/utils/stringutils"
)

func formatHelpText(text string) string {
	processedText := strings.ReplaceAll(text, "\\n", "\n")
	processedText = strings.ReplaceAll(processedText, "'", "`")

	hasNewlines := strings.Contains(processedText, "\n")
	hasBackticks := strings.Contains(processedText, "`")

	if hasNewlines && hasBackticks {
		var sb strings.Builder
		sb.WriteString("`")
		last := 0
		for i, r := range processedText {
			if r == '`' {
				sb.WriteString(processedText[last:i])
				sb.WriteString("`")
				sb.WriteString(" + \"`\" + ")
				sb.WriteString("`")
				last = i + 1
			}
		}
		sb.WriteString(processedText[last:])
		sb.WriteString("`")
		return sb.String()

	} else if hasNewlines {
		return "`" + processedText + "`"
	} else {
		return fmt.Sprintf("%q", processedText)
	}
}

func GetEffectiveEnumValues(opt *metadata.OptionMetadata) []string {
	if opt != nil && opt.EnumValues != nil {
		strValues := make([]string, len(opt.EnumValues))
		for i, v := range opt.EnumValues {
			strValues[i] = fmt.Sprintf("%v", v)
		}
		return strValues
	}
	return nil
}

func Ternary(condition bool, trueVal, falseVal string) string {
	if condition {
		return trueVal
	}
	return falseVal
}

func generateMainContent(cmdMeta *metadata.CommandMetadata, helpText string) (string, error) {
	var sb strings.Builder
	optionsVarName := "options"
	ctxVarName := "ctx"
	isFlagExplicitlySetMapName := "isFlagExplicitlySet"
	globalTempVarPrefix := "temp"

	sb.WriteString(fmt.Sprintf(`// This main function was auto-generated by goat.
func main() {
	%s := context.Background()
	%s := make(map[string]bool)
	var err error
_ = err
`, ctxVarName, isFlagExplicitlySetMapName))

	if helpText != "" {
		sb.WriteString(fmt.Sprintf(`
	flag.Usage = func() {
		fmt.Fprint(os.Stderr, %s)
	}
`, formatHelpText(helpText)))
	}

	// Intentionally keeping sections 1-7 commented for now to test basic structure.
	if cmdMeta.RunFunc.OptionsArgTypeNameStripped != "" {
		sb.WriteString(fmt.Sprintf("\n\n	// --- 1. Initialize Options Struct ---\n"))
		if cmdMeta.RunFunc.InitializerFunc != "" {
			sb.WriteString(fmt.Sprintf("	%s := %s()\n", optionsVarName, cmdMeta.RunFunc.InitializerFunc))
		} else {
			sb.WriteString(fmt.Sprintf("	%s := new(%s)\n", optionsVarName, cmdMeta.RunFunc.OptionsArgTypeNameStripped))
			sb.WriteString("	// Apply default values from struct tags/types\n")
			for _, opt := range cmdMeta.Options {
				handler := GetOptionHandler(opt)
				snippets := handler.GenerateDefaultValueInitializationCode(opt, optionsVarName)
				if snippets.Declarations != "" {
					sb.WriteString(snippets.Declarations)
				}
				if snippets.Logic != "" {
					sb.WriteString(snippets.Logic)
				}
			}
		}

		sb.WriteString(fmt.Sprintf("\n\n	// --- 2. Process Environment Variables ---\n"))
		for _, opt := range cmdMeta.Options {
			if opt.EnvVar == "" {
				continue
			}
			handler := GetOptionHandler(opt)
			envValVarName := stringutils.ToCamelCase(opt.Name) + "EnvVal"
			sb.WriteString(fmt.Sprintf("	if %s, ok := os.LookupEnv(%q); ok {\n", envValVarName, opt.EnvVar))
			snippets := handler.GenerateEnvVarProcessingCode(opt, optionsVarName, envValVarName, ctxVarName)
			if snippets.Declarations != "" {
				sb.WriteString(fmt.Sprintf("		%s", snippets.Declarations))
			}
			if snippets.Logic != "" {
				sb.WriteString(fmt.Sprintf("		%s", snippets.Logic))
			}
			sb.WriteString("	}\n")
		}

		sb.WriteString(fmt.Sprintf("\n\n	// --- 3. Register Flags ---\n"))
		var flagDeclarationsSb strings.Builder
		var flagLogicSb strings.Builder
		for _, opt := range cmdMeta.Options {
			handler := GetOptionHandler(opt)
			snippets := handler.GenerateFlagRegistrationCode(opt, optionsVarName, isFlagExplicitlySetMapName, globalTempVarPrefix)
			if snippets.Declarations != "" {
				flagDeclarationsSb.WriteString(snippets.Declarations)
			}
			if snippets.Logic != "" {
				flagLogicSb.WriteString(snippets.Logic)
			}
		}
		if flagDeclarationsSb.Len() > 0 {
			sb.WriteString(flagDeclarationsSb.String())
			if !strings.HasSuffix(flagDeclarationsSb.String(), "\n") {
				sb.WriteString("\n")
			}
		}
		if flagLogicSb.Len() > 0 {
			sb.WriteString(flagLogicSb.String())
			if !strings.HasSuffix(flagLogicSb.String(), "\n") {
				sb.WriteString("\n")
			}
		}
		sb.WriteString("\n")

		sb.WriteString(fmt.Sprintf("\n	// --- 4. Parse Flags ---\n"))
		sb.WriteString("	flag.Parse()\n")
		sb.WriteString(fmt.Sprintf("	flag.Visit(func(f *flag.Flag) { %s[f.Name] = true })\n", isFlagExplicitlySetMapName))

		sb.WriteString(fmt.Sprintf("\n\n	// --- 5. Post-Parse Flag Assignments (for pointers, etc.) ---\n"))
		var postParseDeclarationsSb strings.Builder
		var postParseLogicSb strings.Builder
		for _, opt := range cmdMeta.Options {
			handler := GetOptionHandler(opt)
			snippets := handler.GenerateFlagPostParseAssignmentCode(opt, optionsVarName, isFlagExplicitlySetMapName, globalTempVarPrefix)
			if snippets.Declarations != "" {
				postParseDeclarationsSb.WriteString(snippets.Declarations)
				if !strings.HasSuffix(snippets.Declarations, "\n") {
					postParseDeclarationsSb.WriteString("\n")
				}
			}
			if snippets.Logic != "" {
				postParseLogicSb.WriteString(snippets.Logic)
				if !strings.HasSuffix(snippets.Logic, "\n") {
					postParseLogicSb.WriteString("\n")
				}
			}
		}
		if postParseDeclarationsSb.Len() > 0 {
			sb.WriteString(postParseDeclarationsSb.String())
		}
		if postParseLogicSb.Len() > 0 {
			sb.WriteString(postParseLogicSb.String())
		}
		sb.WriteString("\n")

		sb.WriteString(fmt.Sprintf("\n	// --- 6. Perform Required Option Checks ---\n"))
		var requiredCheckDeclarations strings.Builder
		initialDefaultsMap := make(map[string]string)
		envWasSetMap := make(map[string]string)

		for _, opt := range cmdMeta.Options { // This loop populates initialDefaultsMap and envWasSetMap, and generates declarations
			if !opt.IsRequired {
				continue
			}
			titleCaseOptName := stringutils.ToTitle(opt.Name)
			initialDefaultVarName := fmt.Sprintf("initialDefault_%s", titleCaseOptName)
			initialDefaultsMap[opt.Name] = initialDefaultVarName

			// Copied from original, previously commented out content
			if opt.DefaultValue != nil {
				switch opt.TypeName {
				case "string":
					valStr, _ := opt.DefaultValue.(string) // Assuming string default is string
					requiredCheckDeclarations.WriteString(fmt.Sprintf("	%s := %s\n", initialDefaultVarName, formatHelpText(valStr)))
				case "[]string":
					// This case might need specific formatting if default is e.g. `[]string{"a", "b"}` vs `"a,b"`
					valStr := fmt.Sprintf("%v", opt.DefaultValue) // General representation
					requiredCheckDeclarations.WriteString(fmt.Sprintf("	%s := %s\n", initialDefaultVarName, formatHelpText(valStr)))
				case "int":
					valNum, ok := opt.DefaultValue.(float64) // JSON numbers are float64
					if !ok {
						// fallback or error - for now, using 0 as a safe default if type is wrong
						requiredCheckDeclarations.WriteString(fmt.Sprintf("	%s := 0 // fallback, unexpected default type %T for int\n", initialDefaultVarName, opt.DefaultValue))
					} else {
						requiredCheckDeclarations.WriteString(fmt.Sprintf("	%s := %d\n", initialDefaultVarName, int(valNum)))
					}
				case "bool":
					valBool, ok := opt.DefaultValue.(bool)
					if !ok {
						requiredCheckDeclarations.WriteString(fmt.Sprintf("	%s := false // fallback, unexpected default type %T for bool\n", initialDefaultVarName, opt.DefaultValue))
					} else {
						requiredCheckDeclarations.WriteString(fmt.Sprintf("	%s := %t\n", initialDefaultVarName, valBool))
					}
				default: // For other types including TextUnmarshaler (ptr or value)
					// For TextUnmarshaler, the initial default is often compared as a string.
					// If DefaultValue is complex, formatHelpText might be needed.
					// For now, assume it's a simple string representable value or handled by TextUnmarshaler's specific logic.
					valStr := fmt.Sprintf("%v", opt.DefaultValue)
					requiredCheckDeclarations.WriteString(fmt.Sprintf("	%s := %s\n", initialDefaultVarName, formatHelpText(valStr)))
				}
			} else { // DefaultValue is nil
				switch opt.TypeName {
				case "string", "[]string": // also covers TextUnmarshaler if its zero value is compared to ""
					requiredCheckDeclarations.WriteString(fmt.Sprintf("	%s := \"\"\n", initialDefaultVarName))
				case "int":
					requiredCheckDeclarations.WriteString(fmt.Sprintf("	%s := 0\n", initialDefaultVarName))
				case "bool":
					requiredCheckDeclarations.WriteString(fmt.Sprintf("	%s := false\n", initialDefaultVarName))
				default:
					if strings.HasPrefix(opt.TypeName, "*") { // For pointers (*int, *string, *MyTextUnmarshaler)
						requiredCheckDeclarations.WriteString(fmt.Sprintf("	var %s %s // Typed nil\n", initialDefaultVarName, opt.TypeName))
					} else if opt.IsTextUnmarshaler { // Non-pointer TextUnmarshaler, zero value might be compared to ""
						requiredCheckDeclarations.WriteString(fmt.Sprintf("	%s := \"\"\n", initialDefaultVarName))
					} else {
						// Fallback for other non-pointer types without explicit default.
						// This case should ideally not be hit for well-defined options.
						requiredCheckDeclarations.WriteString(fmt.Sprintf("	// TODO: Review default for %s (type %s) when opt.DefaultValue is nil.\n", opt.Name, opt.TypeName))
						requiredCheckDeclarations.WriteString(fmt.Sprintf("	%s := \"\"\n", initialDefaultVarName)) // Defaulting to empty string as a placeholder
					}
				}
			}

			envWasSetVarName := fmt.Sprintf("env_%s_WasSet", titleCaseOptName)
			envWasSetMap[opt.Name] = envWasSetVarName
			if opt.EnvVar != "" {
				requiredCheckDeclarations.WriteString(fmt.Sprintf("	_, %s := os.LookupEnv(%q)\n", envWasSetVarName, opt.EnvVar))
			} else {
				requiredCheckDeclarations.WriteString(fmt.Sprintf("	%s := false\n", envWasSetVarName))
			}
		}
		if requiredCheckDeclarations.Len() > 0 {
			sb.WriteString(requiredCheckDeclarations.String())
			if !strings.HasSuffix(requiredCheckDeclarations.String(), "\n") {
				sb.WriteString("\n")
			}
		}

		for _, opt := range cmdMeta.Options { // This loop generates the actual required check logic
			if !opt.IsRequired {
				continue
			}
			handler := GetOptionHandler(opt)
			initialDefaultVar := initialDefaultsMap[opt.Name]
			envWasSetVar := envWasSetMap[opt.Name]
			cliNameForLog := opt.CliName
			if cliNameForLog == "" { // Fallback if CliName is empty
				cliNameForLog = stringutils.ToKebabCase(opt.Name)
			}

			snippets := handler.GenerateRequiredCheckCode(opt, optionsVarName, isFlagExplicitlySetMapName, initialDefaultVar, envWasSetVar, ctxVarName)
			if snippets.Declarations != "" {
				sb.WriteString(snippets.Declarations)
				if !strings.HasSuffix(snippets.Declarations, "\n") {
					sb.WriteString("\n")
				}
			}
			if snippets.Logic != "" {
				logicContent := snippets.Logic
				if !strings.HasSuffix(logicContent, "\n") {
					logicContent += "\n"
				}
				sb.WriteString(fmt.Sprintf("if err = func() error { %s }(); err != nil {\n", logicContent))
				// Ensure cliNameForLog is quoted if it's to be a string literal in the log
				sb.WriteString(fmt.Sprintf("	slog.ErrorContext(%s, \"Error processing required option\", \"option\", %q, \"error\", err)\n", ctxVarName, cliNameForLog))
				sb.WriteString("	os.Exit(1)\n")
				sb.WriteString("}\n")
			}
		}
		sb.WriteString("\n")

		sb.WriteString(fmt.Sprintf("\n	// --- 7. Perform Enum Validations ---\n"))
		for _, opt := range cmdMeta.Options {
			if len(GetEffectiveEnumValues(opt)) == 0 {
				continue
			}
			handler := GetOptionHandler(opt)
			cliNameForLog := opt.CliName
			if cliNameForLog == "" { // Fallback if CliName is empty
				cliNameForLog = stringutils.ToKebabCase(opt.Name)
			}
			snippets := handler.GenerateEnumValidationCode(opt, optionsVarName, ctxVarName)
			if snippets.Declarations != "" {
				sb.WriteString(snippets.Declarations)
				if !strings.HasSuffix(snippets.Declarations, "\n") {
					sb.WriteString("\n")
				}
			}
			if snippets.Logic != "" {
				logicContent := snippets.Logic
				if !strings.HasSuffix(logicContent, "\n") {
					logicContent += "\n"
				}
				sb.WriteString(fmt.Sprintf("if err = func() error { %s }(); err != nil {\n", logicContent))
				sb.WriteString(fmt.Sprintf("	slog.ErrorContext(%s, \"Error validating enum for option\", \"option\", %q, \"error\", err)\n", ctxVarName, cliNameForLog))
				sb.WriteString("	os.Exit(1)\n")
				sb.WriteString("}\n")
			}
		}
		sb.WriteString("\n")
	}

	sb.WriteString(fmt.Sprintf("\n	// --- 8. Execute Run Function ---\n"))
	runFuncCall := ""
	if cmdMeta.RunFunc.ContextArgName != "" {
		if cmdMeta.RunFunc.OptionsArgTypeNameStripped != "" {
			optionsAccessor := optionsVarName
			if !cmdMeta.RunFunc.OptionsArgIsPointer {
				optionsAccessor = "*" + optionsVarName
			}
			runFuncCall = fmt.Sprintf("%s(%s, %s)", cmdMeta.RunFunc.Name, ctxVarName, optionsAccessor)
		} else {
			runFuncCall = fmt.Sprintf("%s(%s)", cmdMeta.RunFunc.Name, ctxVarName)
		}
	} else {
		if cmdMeta.RunFunc.OptionsArgTypeNameStripped != "" {
			optionsAccessor := optionsVarName
			if !cmdMeta.RunFunc.OptionsArgIsPointer {
				optionsAccessor = "*" + optionsVarName
			}
			runFuncCall = fmt.Sprintf("%s(%s)", cmdMeta.RunFunc.Name, optionsAccessor)
		} else {
			runFuncCall = fmt.Sprintf("%s()", cmdMeta.RunFunc.Name)
		}
	}

	sb.WriteString(fmt.Sprintf("	err = %s\n", runFuncCall))
	sb.WriteString(fmt.Sprintf(`if err != nil {
	slog.ErrorContext(%s, "Runtime error from command function", "error", err)
	os.Exit(1)
}
`, ctxVarName))

	sb.WriteString("}\n")
	return sb.String(), nil
}

func GenerateMain(cmdMeta *metadata.CommandMetadata, helpText string, generateFullFile bool) (string, error) {
	if len(cmdMeta.Options) > 0 && cmdMeta.RunFunc.OptionsArgTypeNameStripped == "" {
		return "", fmt.Errorf("OptionsArgTypeNameStripped is empty for command %s, but options are present. This indicates an issue with parsing the run function's options struct type", cmdMeta.Name)
	}

	mainContent, err := generateMainContent(cmdMeta, helpText)
	if err != nil {
		return "", fmt.Errorf("generating main function content: %w", err)
	}

	if generateFullFile {
		var sb strings.Builder
		sb.WriteString("package main\n\n")
		sb.WriteString("import (\n")
		stdImports := []string{
			"context",
			"errors",
			"flag",
			"fmt",
			"os",
			"slices",
			"strconv",
			"strings",
			"log/slog",
		}
		// Add specific imports based on options here if necessary in the future
		sb.WriteString(fmt.Sprintf("\t%q\n", "github.com/podhmo/goat/pkg/textvar")) // For MyTextValue, MyPtrTextValue for tests

		for _, importPath := range stdImports {
			sb.WriteString(fmt.Sprintf("\t%q\n", importPath))
		}
		sb.WriteString(")\n\n")
		sb.WriteString(mainContent)
		return sb.String(), nil
	}
	return mainContent, nil
}
