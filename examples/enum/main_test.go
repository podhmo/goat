package enum

import (
	"os"
	"reflect"
	"strings"
	"testing"

	"github.com/podhmo/goat/examples/enum/customtypes"
)

// Helper function to run the main_goat.go logic (or simulate it for tests)
// This will need to be adapted based on how goat generates the CLI.
// For now, we'll test NewOptions and the generated parser's behavior (hypothetically).
// The actual `runGeneratedCLI` would involve calling the generated `main()` or its core logic.
// Since we don't have the generated code yet, we'll focus on testing what goat *should* do
// with our Options and NewOptions.

// TestDefaultValues checks if the default values are correctly set by NewOptions.
func TestDefaultValues(t *testing.T) {
	opts := NewOptions()
	if opts.LocalEnumField != LocalA {
		t.Errorf("Expected LocalEnumField default to be %s, got %s", LocalA, opts.LocalEnumField)
	}
	if opts.ImportedEnumField != customtypes.OptionX {
		t.Errorf("Expected ImportedEnumField default to be %s, got %s", customtypes.OptionX, opts.ImportedEnumField)
	}
	if opts.OptionalImportedEnumField != nil {
		t.Errorf("Expected OptionalImportedEnumField default to be nil, got %v", *opts.OptionalImportedEnumField)
	}
}

// TestEnvironmentVariableOverrides checks if environment variables correctly override defaults.
func TestEnvironmentVariableOverrides(t *testing.T) {
	tests := []struct {
		name     string
		envKey   string
		envValue string
		asserter func(opts *Options)
	}{
		{
			name:     "Override LocalEnumField",
			envKey:   "ENUM_LOCAL_ENUM",
			envValue: string(LocalB),
			asserter: func(opts *Options) {
				if opts.LocalEnumField != LocalB {
					t.Errorf("Expected LocalEnumField to be %s, got %s", LocalB, opts.LocalEnumField)
				}
			},
		},
		{
			name:     "Override ImportedEnumField",
			envKey:   "ENUM_IMPORTED_ENUM",
			envValue: string(customtypes.OptionY),
			asserter: func(opts *Options) {
				if opts.ImportedEnumField != customtypes.OptionY {
					t.Errorf("Expected ImportedEnumField to be %s, got %s", customtypes.OptionY, opts.ImportedEnumField)
				}
			},
		},
		{
			name:     "Override OptionalImportedEnumField",
			envKey:   "ENUM_OPTIONAL_IMPORTED_ENUM",
			envValue: string(customtypes.OptionY),
			asserter: func(opts *Options) {
				if opts.OptionalImportedEnumField == nil || *opts.OptionalImportedEnumField != customtypes.OptionY {
					t.Errorf("Expected OptionalImportedEnumField to be %s, got %v", customtypes.OptionY, opts.OptionalImportedEnumField)
				}
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			os.Setenv(tt.envKey, tt.envValue)
			defer os.Unsetenv(tt.envKey)

			// Normally, the generated CLI would parse env vars.
			// We simulate this by calling NewOptions() and then manually applying
			// the logic that goat's generated code would use.
			// This is a simplification. After go generate, these tests would ideally
			// run against the generated CLI.
			// For now, we assume goat will generate code that respects these env vars
			// when filling the Options struct.
			// The most direct way to test this *before* generation is limited.
			// We are essentially testing the *specification* of the Options struct + NewOptions.

			// Let's assume for now the generated code will have a parse function or similar
			// For a direct test of env var impact without full CLI run:
			opts := NewOptions() // Get base defaults

			// Manually simulate env var parsing based on struct tags for this test run
			// This is a placeholder for what the generated code would do.
			// In a real generated setup, you'd call a function like `ParseAndRun([]string{})`
			// or similar which handles env vars internally.
			if tt.envKey == "ENUM_LOCAL_ENUM" {
				opts.LocalEnumField = MyLocalEnum(os.Getenv(tt.envKey))
			}
			if tt.envKey == "ENUM_IMPORTED_ENUM" {
				opts.ImportedEnumField = customtypes.MyCustomEnum(os.Getenv(tt.envKey))
			}
			if tt.envKey == "ENUM_OPTIONAL_IMPORTED_ENUM" {
				valStr := os.Getenv(tt.envKey)
				if valStr != "" {
					enumVal := customtypes.MyCustomEnum(valStr)
					opts.OptionalImportedEnumField = &enumVal
				} else {
					opts.OptionalImportedEnumField = nil // Should not happen if env is set
				}
			}

			tt.asserter(opts)
		})
	}
}

// TestCommandLineFlagOverrides requires the generated code to run.
// We will write the test structure, but it will fully pass after `go generate`.
// This test simulates calling the generated CLI with flags.
func TestCommandLineFlagOverrides(t *testing.T) {
	// These tests depend on the actual CLI generated by goat.
	// You would typically use exec.Command to run the compiled CLI with flags.
	// e.g., cmd := exec.Command("./enum_cli", "--local-enum=local-b")
	// For now, we'll test by directly manipulating Options as if flags were parsed.
	// This is less ideal but allows some testing before generation.

	// Placeholder: In a real test after go generate, you would use a helper like:
	// parse := func(args []string) (*Options, error) { /* ... invokes generated parser ... */ }

	t.Run("Override LocalEnumField with flag", func(t *testing.T) {
		opts := NewOptions() // Start with defaults
		// Simulate flag parsing:
		opts.LocalEnumField = LocalB
		if opts.LocalEnumField != LocalB {
			t.Errorf("Expected LocalEnumField to be %s after flag, got %s", LocalB, opts.LocalEnumField)
		}
	})

	t.Run("Override ImportedEnumField with flag", func(t *testing.T) {
		opts := NewOptions() // Start with defaults
		// Simulate flag parsing:
		opts.ImportedEnumField = customtypes.OptionY
		if opts.ImportedEnumField != customtypes.OptionY {
			t.Errorf("Expected ImportedEnumField to be %s after flag, got %s", customtypes.OptionY, opts.ImportedEnumField)
		}
	})

	t.Run("Override OptionalImportedEnumField with flag", func(t *testing.T) {
		opts := NewOptions() // Start with defaults
		// Simulate flag parsing:
		val := customtypes.OptionY
		opts.OptionalImportedEnumField = &val
		if opts.OptionalImportedEnumField == nil || *opts.OptionalImportedEnumField != customtypes.OptionY {
			t.Errorf("Expected OptionalImportedEnumField to be %s after flag, got %v", customtypes.OptionY, opts.OptionalImportedEnumField)
		}
	})

    t.Run("Set OptionalImportedEnumField to empty string (nil)", func(t *testing.T) {
        // This specific test case might depend on how goat handles empty string for optional enums.
        // Assuming an empty string flag or lack of flag for an optional pointer results in nil.
        // If goat has a specific "--no-optional-imported-enum" or similar, that would be tested.
        opts := NewOptions()
        // Simulate providing an "empty" value or no value for the optional flag
        // For a pointer type, not providing the flag should leave it as its default (nil from NewOptions).
        // If a flag like `--optional-imported-enum=""` is passed, goat's behavior for this needs to be known.
        // Let's assume for now that the default nil state is the primary check if the flag is NOT passed.
        // If a flag IS passed with an empty value, this test would need adjustment based on goat's parsing.
        opts.OptionalImportedEnumField = nil // Explicitly set to nil to simulate no flag or empty flag resulting in nil
        if opts.OptionalImportedEnumField != nil {
            t.Errorf("Expected OptionalImportedEnumField to be nil, got %v", *opts.OptionalImportedEnumField)
        }
    })
}


// TestInvalidEnumValues requires the validation logic from the generated code.
// We'll write the test structure for what we expect goat to validate.
func TestInvalidEnumValues(t *testing.T) {
	// This test also relies on the generated CLI's validation.
	// You would check for errors or exit codes when providing invalid enum values.
	// e.g., run `enum_cli --local-enum=invalid-value` and expect an error.

	// Placeholder: Simulate providing invalid values and expecting some form of error.
	// The actual test would involve:
	// 1. Running the generated CLI with an invalid flag.
	// 2. Checking if the CLI exits with an error code.
	// 3. Optionally, checking if stderr contains a relevant error message.

	// Example structure (would not run correctly without generated main and parser)
	t.Run("Invalid LocalEnumField", func(t *testing.T) {
		// Hypothetical call to a parsing function from the generated code
		// _, err := ParseArgsAndBuildOptions([]string{"--local-enum=invalid-value"})
		// if err == nil {
		//    t.Errorf("Expected error for invalid local enum value, got nil")
		// }
		// This is a conceptual test. Actual implementation depends on generated code.
		// For now, we acknowledge this test will be more effective after `go generate`.
		t.Log("Skipping full invalid LocalEnumField test until go generate produces the CLI parser.")
	})

	t.Run("Invalid ImportedEnumField", func(t *testing.T) {
		// _, err := ParseArgsAndBuildOptions([]string{"--imported-enum=invalid-value"})
		// if err == nil {
		//    t.Errorf("Expected error for invalid imported enum value, got nil")
		// }
		t.Log("Skipping full invalid ImportedEnumField test until go generate produces the CLI parser.")
	})

    t.Run("Invalid OptionalImportedEnumField", func(t *testing.T) {
		// _, err := ParseArgsAndBuildOptions([]string{"--optional-imported-enum=invalid-value"})
		// if err == nil {
		//    t.Errorf("Expected error for invalid optional imported enum value, got nil")
		// }
		t.Log("Skipping full invalid OptionalImportedEnumField test until go generate produces the CLI parser.")
	})
}

// Note: The tests for command-line flags and invalid values are structured
// but will become fully effective and verifiable once `go generate` is run and
// the actual CLI argument parsing and validation logic is generated by goat.
// The current environment variable tests make some assumptions about how
// the generated code will behave based on struct tags and NewOptions.
