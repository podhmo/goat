package main

import (
	"context"
	"flag"
	"fmt"
	"log/slog"
	"net"
	"os"
	"strconv"
	"strings"

	"github.com/podhmo/goat"
)

// stringPtr is a helper function to get a pointer to a string.
func stringPtr(s string) *string {
	return &s
}

//go:generate goat emit -run run -initializer NewOptions main.go

// Options defines the command line options for this simple example tool.
// This tool demonstrates the basic capabilities of goat for CLI generation.
type Options struct {
	// Name of the person to greet. This is a mandatory field.
	Name string `env:"SIMPLE_NAME"`

	// Age of the person. This is an optional field.
	Age *int `env:"SIMPLE_AGE"`

	// LogLevel for the application output.
	// It can be one of: debug, info, warning, error.
	LogLevel string `env:"SIMPLE_LOG_LEVEL"`

	// Features to enable, provided as a comma-separated list.
	// Example: --features feat1,feat2
	Features []string `env:"SIMPLE_FEATURES"`

	// OutputDir for any generated files or reports.
	// Defaults to "output" if not specified by the user.
	OutputDir string

	// Mode of operation for the tool, affecting its behavior.
	Mode string `env:"SIMPLE_MODE"`

	// Enable extra verbose output.
	SuperVerbose bool `env:"SIMPLE_SUPER_VERBOSE"`

	// An optional boolean flag with no default, should be nil if not set.
	OptionalToggle *bool
	// Path to a configuration file. Must exist. (env:"FULLSET_CONFIG_FILE")
	ConfigFile string `env:"FULLSET_CONFIG_FILE"`
	// A glob pattern for input files. (env:"FULLSET_PATTERN")
	Pattern string `env:"FULLSET_PATTERN"`
	// Enable Feature X by default. Use --no-enable-feature-x to disable. (env:"FULLSET_FEATURE_X")
	EnableFeatureX bool `env:"FULLSET_FEATURE_X"`
	// The host IP address for the service. (env:"FULLSET_HOST_IP")
	HostIP net.IP `env:"FULLSET_HOST_IP"`
	// Example of an existing field made optional. (env:"FULLSET_OPTIONAL_EXISTING")
	ExistingFieldToMakeOptional *string `env:"FULLSET_OPTIONAL_EXISTING"`
}

// NewOptions initializes Options with default values and enum constraints.
// This function will be "interpreted" by the goat tool.
func NewOptions() *Options {
	return &Options{
		// Existing fields from original
		Name:      goat.Default("World"),
		LogLevel:  goat.Default("info", goat.Enum([]string{"debug", "info", "warning", "error"})),
		OutputDir: goat.Default("output"),
		Mode:      goat.Default("standard", goat.Enum([]string{"standard", "turbo", "eco"})),
		// Age is optional (pointer) and has no default here. It remains *int.
		// Features is []string, handled by flag package. Env var should work.
		// SuperVerbose is a bool, defaults to false (zero value for bool).

		// New fields from first subtask, adapted for current subtask
		// OptionalToggle is *bool and should not have goat.Default()
		ConfigFile:                  goat.Default("config.json"),
		Pattern:                     goat.Default("*.go"),
		EnableFeatureX:              goat.Default(true),
		HostIP:                      goat.Default(net.ParseIP("127.0.0.1")),
		ExistingFieldToMakeOptional: goat.Default(stringPtr("was set by default")),
	}
}

// run is the core logic for this CLI tool.
// It receives the parsed and validated options.
// This function's doc comment is used as the main help text for the command.
func run(ctx context.Context, opts *Options) error {
	fmt.Printf("Hello, %s!\n", opts.Name)

	if opts.Age != nil {
		fmt.Printf("You are %d years old.\n", *opts.Age)
	} else {
		fmt.Println("Your age was not provided.")
	}

	fmt.Printf("Log Level: %s\n", opts.LogLevel)
	fmt.Printf("Output Directory: %s\n", opts.OutputDir)
	fmt.Printf("Mode: %s\n", opts.Mode)

	if len(opts.Features) > 0 {
		fmt.Printf("Enabled features: %v\n", opts.Features)
	} else {
		fmt.Println("No special features enabled.")
	}

	if opts.SuperVerbose {
		fmt.Println("Super verbose mode is ON!")
	}

	// Print new fields from first subtask
	if opts.OptionalToggle != nil {
		fmt.Printf("OptionalToggle: %t\n", *opts.OptionalToggle)
	} else {
		fmt.Println("OptionalToggle: not set")
	}
	fmt.Printf("ConfigFile: %s\n", opts.ConfigFile)
	fmt.Printf("Pattern: %s\n", opts.Pattern)
	fmt.Printf("EnableFeatureX: %t\n", opts.EnableFeatureX)
	fmt.Printf("Host IP: %s\n", opts.HostIP)
	if opts.ExistingFieldToMakeOptional != nil {
		fmt.Printf("ExistingFieldToMakeOptional: %s\n", *opts.ExistingFieldToMakeOptional)
	} else {
		fmt.Println("ExistingFieldToMakeOptional: not set")
	}

	if opts.Name == "ErrorTrigger" {
		return fmt.Errorf("the name 'ErrorTrigger' is not allowed")
	}

	return nil
}

// This main function was auto-generated by goat.
func main() {
	ctx := context.Background()
	isFlagExplicitlySet := make(map[string]bool)
	var err error
	_ = err

	flag.Usage = func() {
		fmt.Fprint(os.Stderr, `fullset - run is the core logic for this CLI tool.
         It receives the parsed and validated options.
         This function`+"`"+`s doc comment is used as the main help text for the command.

Usage:
  fullset [flags]

Flags:
  --name                            string   Name of the person to greet. This is a mandatory field. (default: "World") (env: SIMPLE_NAME)
  --age                             int      Age of the person. This is an optional field. (env: SIMPLE_AGE)
  --log-level                       string   LogLevel for the application output.
                                           It can be one of: debug, info, warning, error. (default: "info") (env: SIMPLE_LOG_LEVEL) (allowed: "debug", "info", "warning", "error")
  --features                        strings  Features to enable, provided as a comma-separated list.
                                           Example: --features feat1,feat2 (required) (env: SIMPLE_FEATURES)
  --output-dir                      string   OutputDir for any generated files or reports.
                                           Defaults to "output" if not specified by the user. (default: "output")
  --mode                            string   Mode of operation for the tool, affecting its behavior. (default: "standard") (env: SIMPLE_MODE) (allowed: "standard", "turbo", "eco")
  --super-verbose                   bool     Enable extra verbose output. (env: SIMPLE_SUPER_VERBOSE)
  --optional-toggle                 bool     An optional boolean flag with no default, should be nil if not set.
  --config-file                     string   Path to a configuration file. Must exist. (env:"FULLSET_CONFIG_FILE") (default: "config.json") (env: FULLSET_CONFIG_FILE)
  --pattern                         string   A glob pattern for input files. (env:"FULLSET_PATTERN") (default: "*.go") (env: FULLSET_PATTERN)
  --no-enable-feature-x             bool     Enable Feature X by default. Use --no-enable-feature-x to disable. (env:"FULLSET_FEATURE_X") (env: FULLSET_FEATURE_X)
  --host-ip                         ip       The host IP address for the service. (env:"FULLSET_HOST_IP") (required) (env: FULLSET_HOST_IP)
  --existing-field-to-make-optional string   Example of an existing field made optional. (env:"FULLSET_OPTIONAL_EXISTING") (env: FULLSET_OPTIONAL_EXISTING)

  -h, --help                                Show this help message and exit
`)
	}

	// --- 1. Initialize Options Struct ---
	options := NewOptions()

	// --- 2. Process Environment Variables ---
	if nameEnvVal, ok := os.LookupEnv("SIMPLE_NAME"); ok {
		options.Name = nameEnvVal
	}
	if ageEnvVal, ok := os.LookupEnv("SIMPLE_AGE"); ok {

		if v, err := strconv.Atoi(ageEnvVal); err == nil {
			valCopy := v
			options.Age = &valCopy
		} else {
			slog.WarnContext(ctx, "Invalid integer value for environment variable", "variable", "SIMPLE_AGE", "value", ageEnvVal, "error", err)
		}
	}
	if loglevelEnvVal, ok := os.LookupEnv("SIMPLE_LOG_LEVEL"); ok {
		options.LogLevel = loglevelEnvVal
	}
	if featuresEnvVal, ok := os.LookupEnv("SIMPLE_FEATURES"); ok {
		if featuresEnvVal != "" {
			options.Features = strings.Split(featuresEnvVal, ",")
		}
	}
	if modeEnvVal, ok := os.LookupEnv("SIMPLE_MODE"); ok {
		options.Mode = modeEnvVal
	}
	if superverboseEnvVal, ok := os.LookupEnv("SIMPLE_SUPER_VERBOSE"); ok {

		if v, err := strconv.ParseBool(superverboseEnvVal); err == nil {
			options.SuperVerbose = v
		} else {
			slog.WarnContext(ctx, "Invalid boolean value for environment variable", "variable", "SIMPLE_SUPER_VERBOSE", "value", superverboseEnvVal, "error", err)
		}
	}
	if configfileEnvVal, ok := os.LookupEnv("FULLSET_CONFIG_FILE"); ok {
		options.ConfigFile = configfileEnvVal
	}
	if patternEnvVal, ok := os.LookupEnv("FULLSET_PATTERN"); ok {
		options.Pattern = patternEnvVal
	}
	if enablefeaturexEnvVal, ok := os.LookupEnv("FULLSET_FEATURE_X"); ok {

		if v, err := strconv.ParseBool(enablefeaturexEnvVal); err == nil {
			options.EnableFeatureX = v
		} else {
			slog.WarnContext(ctx, "Invalid boolean value for environment variable", "variable", "FULLSET_FEATURE_X", "value", enablefeaturexEnvVal, "error", err)
		}
	}
	if hostipEnvVal, ok := os.LookupEnv("FULLSET_HOST_IP"); ok {

		if err := options.HostIP.UnmarshalText([]byte(hostipEnvVal)); err != nil {
			slog.WarnContext(ctx, "Failed to unmarshal environment variable for TextUnmarshaler option", "variable", "FULLSET_HOST_IP", "value", hostipEnvVal, "error", err)
		}
	}
	if existingfieldtomakeoptionalEnvVal, ok := os.LookupEnv("FULLSET_OPTIONAL_EXISTING"); ok {
		{
			valCopy := existingfieldtomakeoptionalEnvVal
			options.ExistingFieldToMakeOptional = &valCopy
		}
	}

	// --- 3. Register Flags ---
	isAgeNilInitially := options.Age == nil
	var tempAgeVal int
	var defaultAgeValForFlag int
	if !isAgeNilInitially {
		defaultAgeValForFlag = *options.Age
	}
	isOptionaltoggleNilInitially := options.OptionalToggle == nil
	var tempOptionaltoggleVal bool
	var defaultOptionaltoggleValForFlag bool
	if !isOptionaltoggleNilInitially {
		defaultOptionaltoggleValForFlag = *options.OptionalToggle
	}
	var tempEnablefeaturexNoFlagPresent bool
	isExistingfieldtomakeoptionalNilInitially := options.ExistingFieldToMakeOptional == nil
	var tempExistingfieldtomakeoptionalVal string
	var defaultExistingfieldtomakeoptionalValForFlag string
	if !isExistingfieldtomakeoptionalNilInitially {
		defaultExistingfieldtomakeoptionalValForFlag = *options.ExistingFieldToMakeOptional
	}
	flag.StringVar(&options.Name, "name", "World", "Name of the person to greet. This is a mandatory field. (default: World) (env: SIMPLE_NAME)")
	if isAgeNilInitially {
		flag.IntVar(&tempAgeVal, "age", 0, "Age of the person. This is an optional field. (env: SIMPLE_AGE)")
	} else {
		flag.IntVar(options.Age, "age", defaultAgeValForFlag, "Age of the person. This is an optional field. (env: SIMPLE_AGE)")
	}
	flag.StringVar(&options.LogLevel, "log-level", "info", `LogLevel for the application output.
It can be one of: debug, info, warning, error. (default: info) (allowed: debug, info, warning, error) (env: SIMPLE_LOG_LEVEL)`)
	flag.Func("features", `Features to enable, provided as a comma-separated list.
Example: --features feat1,feat2 (env: SIMPLE_FEATURES)`, func(s string) error {
		isFlagExplicitlySet["features"] = true
		options.Features = strings.Split(s, ",")
		return nil
	})
	flag.StringVar(&options.OutputDir, "output-dir", "output", `OutputDir for any generated files or reports.
Defaults to "output" if not specified by the user. (default: output)`)
	flag.StringVar(&options.Mode, "mode", "standard", "Mode of operation for the tool, affecting its behavior. (default: standard) (allowed: standard, turbo, eco) (env: SIMPLE_MODE)")
	flag.BoolVar(&options.SuperVerbose, "super-verbose", false, "Enable extra verbose output. (default: false) (env: SIMPLE_SUPER_VERBOSE)")
	if isOptionaltoggleNilInitially {
		flag.BoolVar(&tempOptionaltoggleVal, "optional-toggle", false, "An optional boolean flag with no default, should be nil if not set. (default: false)")
	} else {
		flag.BoolVar(options.OptionalToggle, "optional-toggle", defaultOptionaltoggleValForFlag, "An optional boolean flag with no default, should be nil if not set. (default: false)")
	}
	flag.StringVar(&options.ConfigFile, "config-file", "config.json", "Path to a configuration file. Must exist. (env:\"FULLSET_CONFIG_FILE\") (default: config.json) (env: FULLSET_CONFIG_FILE)")
	flag.StringVar(&options.Pattern, "pattern", "*.go", "A glob pattern for input files. (env:\"FULLSET_PATTERN\") (default: *.go) (env: FULLSET_PATTERN)")
	flag.BoolVar(&tempEnablefeaturexNoFlagPresent, "no-enable-feature-x", false, "Set enable-feature-x to false, overriding default true")
	flag.BoolVar(&options.EnableFeatureX, "enable-feature-x", true, "Enable Feature X by default. Use --no-enable-feature-x to disable. (env:\"FULLSET_FEATURE_X\") (default: true) (env: FULLSET_FEATURE_X)")

	flag.Func("host-ip", "The host IP address for the service. (env:\"FULLSET_HOST_IP\") (env: FULLSET_HOST_IP)", func(s string) error {
		isFlagExplicitlySet["host-ip"] = true
		return options.HostIP.UnmarshalText([]byte(s))
	})
	if isExistingfieldtomakeoptionalNilInitially {
		flag.StringVar(&tempExistingfieldtomakeoptionalVal, "existing-field-to-make-optional", "", "Example of an existing field made optional. (env:\"FULLSET_OPTIONAL_EXISTING\") (env: FULLSET_OPTIONAL_EXISTING)")
	} else {
		flag.StringVar(options.ExistingFieldToMakeOptional, "existing-field-to-make-optional", defaultExistingfieldtomakeoptionalValForFlag, "Example of an existing field made optional. (env:\"FULLSET_OPTIONAL_EXISTING\") (env: FULLSET_OPTIONAL_EXISTING)")
	}

	// --- 4. Parse Flags ---
	flag.Parse()
	flag.Visit(func(f *flag.Flag) { isFlagExplicitlySet[f.Name] = true })

	// --- 5. Post-Parse Flag Assignments (for pointers, etc.) ---
	if isAgeNilInitially && isFlagExplicitlySet["age"] {
		options.Age = &tempAgeVal
	}
	if isOptionaltoggleNilInitially && isFlagExplicitlySet["optional-toggle"] {
		options.OptionalToggle = &tempOptionaltoggleVal
	}
	if isFlagExplicitlySet["no-enable-feature-x"] {
		options.EnableFeatureX = false
	}
	if isExistingfieldtomakeoptionalNilInitially && isFlagExplicitlySet["existing-field-to-make-optional"] {
		options.ExistingFieldToMakeOptional = &tempExistingfieldtomakeoptionalVal
	}

	// --- 6. Perform Required Option Checks ---
	initialDefault_Name := "World"
	_, env_Name_WasSet := os.LookupEnv("SIMPLE_NAME")
	initialDefault_Loglevel := "info"
	_, env_Loglevel_WasSet := os.LookupEnv("SIMPLE_LOG_LEVEL")
	initialDefault_Features := ""
	_, env_Features_WasSet := os.LookupEnv("SIMPLE_FEATURES")
	initialDefault_Outputdir := "output"
	env_Outputdir_WasSet := false
	initialDefault_Mode := "standard"
	_, env_Mode_WasSet := os.LookupEnv("SIMPLE_MODE")
	initialDefault_Superverbose := false
	_, env_Superverbose_WasSet := os.LookupEnv("SIMPLE_SUPER_VERBOSE")
	initialDefault_Configfile := "config.json"
	_, env_Configfile_WasSet := os.LookupEnv("FULLSET_CONFIG_FILE")
	initialDefault_Pattern := "*.go"
	_, env_Pattern_WasSet := os.LookupEnv("FULLSET_PATTERN")
	initialDefault_Enablefeaturex := true
	_, env_Enablefeaturex_WasSet := os.LookupEnv("FULLSET_FEATURE_X")
	initialDefault_Hostip := ""
	_, env_Hostip_WasSet := os.LookupEnv("FULLSET_HOST_IP")
	if err = func() error {
		if options.Name == initialDefault_Name && !isFlagExplicitlySet["name"] && !env_Name_WasSet {
			slog.ErrorContext(ctx, "Missing required option", "flag", "name", "envVar", "SIMPLE_NAME", "option", "Name")
			return fmt.Errorf("missing required option: --name / SIMPLE_NAME")
		}
		return nil
	}(); err != nil {
		slog.ErrorContext(ctx, "Error processing required option", "option", "name", "error", err)
		os.Exit(1)
	}
	if err = func() error {
		if options.LogLevel == initialDefault_Loglevel && !isFlagExplicitlySet["log-level"] && !env_Loglevel_WasSet {
			slog.ErrorContext(ctx, "Missing required option", "flag", "log-level", "envVar", "SIMPLE_LOG_LEVEL", "option", "LogLevel")
			return fmt.Errorf("missing required option: --log-level / SIMPLE_LOG_LEVEL")
		}
		return nil
	}(); err != nil {
		slog.ErrorContext(ctx, "Error processing required option", "option", "log-level", "error", err)
		os.Exit(1)
	}
	if err = func() error {
		if len(options.Features) == 0 && !isFlagExplicitlySet["features"] && !env_Features_WasSet {
			slog.ErrorContext(ctx, "Missing required option", "flag", "features", "envVar", "SIMPLE_FEATURES", "option", "Features")
			return fmt.Errorf("missing required option: --features / SIMPLE_FEATURES")
		}
	}(); err != nil {
		slog.ErrorContext(ctx, "Error processing required option", "option", "features", "error", err)
		os.Exit(1)
	}
	if err = func() error {
		if options.OutputDir == initialDefault_Outputdir && !isFlagExplicitlySet["output-dir"] && !env_Outputdir_WasSet {
			slog.ErrorContext(ctx, "Missing required option", "flag", "output-dir", "option", "OutputDir")
			return fmt.Errorf("missing required option: --output-dir / ")
		}
		return nil
	}(); err != nil {
		slog.ErrorContext(ctx, "Error processing required option", "option", "output-dir", "error", err)
		os.Exit(1)
	}
	if err = func() error {
		if options.Mode == initialDefault_Mode && !isFlagExplicitlySet["mode"] && !env_Mode_WasSet {
			slog.ErrorContext(ctx, "Missing required option", "flag", "mode", "envVar", "SIMPLE_MODE", "option", "Mode")
			return fmt.Errorf("missing required option: --mode / SIMPLE_MODE")
		}
		return nil
	}(); err != nil {
		slog.ErrorContext(ctx, "Error processing required option", "option", "mode", "error", err)
		os.Exit(1)
	}
	if err = func() error {
		if options.SuperVerbose == initialDefault_Superverbose && !isFlagExplicitlySet["super-verbose"] && !env_Superverbose_WasSet {
			slog.ErrorContext(ctx, "Missing required boolean option (must be explicitly set)", "flag", "super-verbose", "envVar", "SIMPLE_SUPER_VERBOSE", "option", "SuperVerbose")
			return fmt.Errorf("missing or not explicitly set required option: --super-verbose / SIMPLE_SUPER_VERBOSE")
		}
		return nil
	}(); err != nil {
		slog.ErrorContext(ctx, "Error processing required option", "option", "super-verbose", "error", err)
		os.Exit(1)
	}
	if err = func() error {
		if options.ConfigFile == initialDefault_Configfile && !isFlagExplicitlySet["config-file"] && !env_Configfile_WasSet {
			slog.ErrorContext(ctx, "Missing required option", "flag", "config-file", "envVar", "FULLSET_CONFIG_FILE", "option", "ConfigFile")
			return fmt.Errorf("missing required option: --config-file / FULLSET_CONFIG_FILE")
		}
		return nil
	}(); err != nil {
		slog.ErrorContext(ctx, "Error processing required option", "option", "config-file", "error", err)
		os.Exit(1)
	}
	if err = func() error {
		if options.Pattern == initialDefault_Pattern && !isFlagExplicitlySet["pattern"] && !env_Pattern_WasSet {
			slog.ErrorContext(ctx, "Missing required option", "flag", "pattern", "envVar", "FULLSET_PATTERN", "option", "Pattern")
			return fmt.Errorf("missing required option: --pattern / FULLSET_PATTERN")
		}
		return nil
	}(); err != nil {
		slog.ErrorContext(ctx, "Error processing required option", "option", "pattern", "error", err)
		os.Exit(1)
	}
	if err = func() error {
		if options.EnableFeatureX == initialDefault_Enablefeaturex && !isFlagExplicitlySet["enable-feature-x"] && !env_Enablefeaturex_WasSet {
			slog.ErrorContext(ctx, "Missing required boolean option (must be explicitly set)", "flag", "enable-feature-x", "envVar", "FULLSET_FEATURE_X", "option", "EnableFeatureX")
			return fmt.Errorf("missing or not explicitly set required option: --enable-feature-x / FULLSET_FEATURE_X")
		}
		return nil
	}(); err != nil {
		slog.ErrorContext(ctx, "Error processing required option", "option", "enable-feature-x", "error", err)
		os.Exit(1)
	}
	var hostipCurrentTextVal []byte
	if err = func() error {
		hostipCurrentTextVal, err := options.HostIP.MarshalText()
		if err != nil {
			slog.WarnContext(ctx, "Failed to marshal current value for TextUnmarshaler option for required check", "option", "host-ip", "error", err)
			return fmt.Errorf("failed to marshal current value for option host-ip for required check: %w", err)
		}

		if string(hostipCurrentTextVal) == initialDefault_Hostip && !isFlagExplicitlySet["host-ip"] && !env_Hostip_WasSet {
			slog.ErrorContext(ctx, "Missing required option", "flag", "host-ip", "envVar", "FULLSET_HOST_IP", "option", "HostIP")
			return fmt.Errorf("missing required option: --host-ip / FULLSET_HOST_IP")
		}
		return nil // Added this line
	}(); err != nil {
		slog.ErrorContext(ctx, "Error processing required option", "option", "host-ip", "error", err)
		os.Exit(1)
	}

	// --- 7. Perform Enum Validations ---
	var loglevelEnumValues = []string{"debug", "info", "warning", "error"}
	if err = func() error {
		found := false
		for _, validVal := range loglevelEnumValues {
			if options.LogLevel == validVal {
				found = true
				break
			}
		}
		if !found {
			slog.ErrorContext(ctx, "Invalid value for option", "option", "log-level", "value", options.LogLevel, "allowed", loglevelEnumValues)
			return fmt.Errorf("invalid value for --log-level: got %q, expected one of %v", options.LogLevel, loglevelEnumValues)
		}
		return nil // Added this line
	}(); err != nil {
		slog.ErrorContext(ctx, "Error validating enum for option", "option", "log-level", "error", err)
		os.Exit(1)
	}
	var modeEnumValues = []string{"standard", "turbo", "eco"}
	if err = func() error {
		found := false
		for _, validVal := range modeEnumValues {
			if options.Mode == validVal {
				found = true
				break
			}
		}
		if !found {
			slog.ErrorContext(ctx, "Invalid value for option", "option", "mode", "value", options.Mode, "allowed", modeEnumValues)
			return fmt.Errorf("invalid value for --mode: got %q, expected one of %v", options.Mode, modeEnumValues)
		}
		return nil // Added this line
	}(); err != nil {
		slog.ErrorContext(ctx, "Error validating enum for option", "option", "mode", "error", err)
		os.Exit(1)
	}

	// --- 8. Execute Run Function ---
	err = run(ctx, options)
	if err != nil {
		slog.ErrorContext(ctx, "Runtime error from command function", "error", err)
		os.Exit(1)
	}
}

// ConfigureOptions would be options for a hypothetical 'configure' command.
type ConfigureOptions struct {
	Name    string `env:"CONFIGURE_NAME"`
	Verbose bool   `env:"CONFIGURE_VERBOSE"`
	Mode    string `env:"CONFIGURE_MODE"`
	Port    int    `env:"CONFIGURE_PORT"`
}

// NewConfigureOptions provides default values for ConfigureOptions.
func NewConfigureOptions() *ConfigureOptions {
	return &ConfigureOptions{
		Name:    "DefaultFullsetName",
		Verbose: true,
		// Mode and Port will use their zero values (empty string, 0)
		// or rely on struct tags for other defaults if those were supported by the initializer directly.
		// For this example, explicit initialization is sufficient.
	}
}
